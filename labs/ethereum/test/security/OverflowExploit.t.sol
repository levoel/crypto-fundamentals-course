// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

// Integer Overflow Exploit Test (SEC-03)
// Run: forge test --match-path test/security/OverflowExploit.t.sol -vvv
//
// Tests:
// 1. Safe add: reverts on uint8 overflow (Solidity 0.8+ default)
// 2. Unchecked add: wraps on overflow (255 + 1 = 0)
// 3. Unsafe downcast: truncates silently (uint256 -> uint8)
// 4. BatchOverflow demo: multiplication overflow in unchecked{}

import "forge-std/Test.sol";
import "../../contracts/security/LegacyOverflow.sol";

contract OverflowExploitTest is Test {
    LegacyOverflow public overflow;

    function setUp() public {
        overflow = new LegacyOverflow();
    }

    // ---------------------------------------------------------------
    //  Safe: default checked arithmetic reverts on overflow
    // ---------------------------------------------------------------

    function test_safeAddNormal() public view {
        uint8 result = overflow.safeAdd(100, 50);
        assertEq(result, 150, "100 + 50 = 150");
    }

    function test_safeAddBoundary() public view {
        uint8 result = overflow.safeAdd(255, 0);
        assertEq(result, 255, "255 + 0 = 255");
    }

    function test_safeAddReverts() public {
        // 255 + 1 should revert with Panic(0x11) -- arithmetic overflow
        vm.expectRevert();
        overflow.safeAdd(255, 1);
    }

    function test_safeAddRevertsLarger() public {
        // 200 + 100 = 300 > 255 -- should revert
        vm.expectRevert();
        overflow.safeAdd(200, 100);
    }

    // ---------------------------------------------------------------
    //  Unchecked: wraps silently on overflow
    // ---------------------------------------------------------------

    function test_uncheckedAddNormal() public view {
        uint8 result = overflow.uncheckedAdd(100, 50);
        assertEq(result, 150, "100 + 50 = 150 (unchecked, no overflow)");
    }

    function test_uncheckedAddWraps() public view {
        // 255 + 1 wraps to 0 in unchecked{}
        uint8 result = overflow.uncheckedAdd(255, 1);
        assertEq(result, 0, "255 + 1 = 0 (wrapped!)");
    }

    function test_uncheckedAddWrapsLarger() public view {
        // 200 + 100 = 300 -> 300 - 256 = 44
        uint8 result = overflow.uncheckedAdd(200, 100);
        assertEq(result, 44, "200 + 100 = 44 (wrapped: 300 mod 256)");
    }

    function test_uncheckedMaxWrap() public view {
        // 255 + 255 = 510 -> 510 - 256 - 256 = 510 mod 256 = 254
        uint8 result = overflow.uncheckedAdd(255, 255);
        assertEq(result, 254, "255 + 255 = 254 (wrapped: 510 mod 256)");
    }

    // ---------------------------------------------------------------
    //  Unsafe downcast: truncates silently
    // ---------------------------------------------------------------

    function test_downcastSafe() public view {
        // Values 0-255 survive downcast
        uint8 result = overflow.unsafeDowncast(200);
        assertEq(result, 200, "200 fits in uint8");
    }

    function test_downcastTruncates256() public view {
        // 256 -> uint8 = 0 (only lower 8 bits: 0x100 & 0xFF = 0x00)
        uint8 result = overflow.unsafeDowncast(256);
        assertEq(result, 0, "256 truncated to 0");
    }

    function test_downcastTruncates257() public view {
        // 257 -> uint8 = 1 (0x101 & 0xFF = 0x01)
        uint8 result = overflow.unsafeDowncast(257);
        assertEq(result, 1, "257 truncated to 1");
    }

    function test_downcastTruncatesLarge() public view {
        // 1000 -> uint8 = 232 (1000 mod 256 = 232)
        uint8 result = overflow.unsafeDowncast(1000);
        assertEq(result, 232, "1000 truncated to 232");
    }

    function test_downcastMaxUint256() public view {
        // type(uint256).max & 0xFF = 255
        uint8 result = overflow.unsafeDowncast(type(uint256).max);
        assertEq(result, 255, "max uint256 truncated to 255");
    }

    // ---------------------------------------------------------------
    //  BatchOverflow demo
    // ---------------------------------------------------------------

    function test_batchOverflowDemo() public view {
        // Simulate BatchOverflow: huge amount * 2 overflows to small total
        // amount = type(uint256).max / 2 + 1, count = 2
        // total = (max/2 + 1) * 2 = max + 2 = overflow -> 0
        uint256 amount = type(uint256).max / 2 + 1;
        uint256 count = 2;

        (uint256 total, uint256 perRecipient) = overflow.batchOverflowDemo(amount, count);

        // total overflows to 0, but each recipient gets the huge amount
        assertEq(total, 0, "Total overflowed to 0");
        assertEq(perRecipient, amount, "Each recipient gets huge amount");

        // This is the BatchOverflow pattern:
        // require(total <= balances[msg.sender]) passes because total = 0
        // But 'count' recipients each receive 'amount' tokens
    }
}
