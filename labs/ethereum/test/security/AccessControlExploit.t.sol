// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

// Access Control Exploit Test (SEC-04)
// Run: forge test --match-path test/security/AccessControlExploit.t.sol -vvv
//
// Tests:
// 1. Exploit: attacker mints unlimited tokens on UnsafeToken
// 2. Exploit: attacker burns other users' tokens on UnsafeToken
// 3. Defense: UnsafeTokenFixed reverts unauthorized mint
// 4. Defense: UnsafeTokenFixed allows owner to mint

import "forge-std/Test.sol";
import "../../contracts/security/UnsafeToken.sol";
import "../../contracts/security/UnsafeTokenFixed.sol";

contract AccessControlExploitTest is Test {
    UnsafeToken public unsafeToken;
    UnsafeTokenFixed public fixedToken;

    address deployer = makeAddr("deployer");
    address alice = makeAddr("alice");
    address attacker = makeAddr("attacker");

    function setUp() public {
        vm.prank(deployer);
        unsafeToken = new UnsafeToken();

        vm.prank(deployer);
        fixedToken = new UnsafeTokenFixed(deployer);

        // Transfer some tokens to alice on both contracts
        vm.prank(deployer);
        unsafeToken.transfer(alice, 100_000 * 1e18);

        vm.prank(deployer);
        fixedToken.transfer(alice, 100_000 * 1e18);
    }

    // ---------------------------------------------------------------
    //  Exploit: Attacker mints unlimited tokens (UnsafeToken)
    // ---------------------------------------------------------------

    function test_attackerCanMintUnlimited() public {
        uint256 supplyBefore = unsafeToken.totalSupply();

        // Attacker mints 1 billion tokens to themselves
        vm.prank(attacker);
        unsafeToken.mint(attacker, 1_000_000_000 * 1e18);

        uint256 attackerBalance = unsafeToken.balanceOf(attacker);
        assertEq(attackerBalance, 1_000_000_000 * 1e18, "Attacker minted 1B tokens");

        uint256 supplyAfter = unsafeToken.totalSupply();
        assertEq(supplyAfter, supplyBefore + 1_000_000_000 * 1e18, "Supply inflated");
    }

    // ---------------------------------------------------------------
    //  Exploit: Attacker burns other users' tokens
    // ---------------------------------------------------------------

    function test_attackerCanBurnOthersTokens() public {
        uint256 aliceBalanceBefore = unsafeToken.balanceOf(alice);
        assertEq(aliceBalanceBefore, 100_000 * 1e18);

        // Attacker burns ALL of Alice's tokens
        vm.prank(attacker);
        unsafeToken.burn(alice, 100_000 * 1e18);

        uint256 aliceBalanceAfter = unsafeToken.balanceOf(alice);
        assertEq(aliceBalanceAfter, 0, "Alice lost all tokens");
    }

    // ---------------------------------------------------------------
    //  Defense: Fixed token reverts unauthorized mint
    // ---------------------------------------------------------------

    function test_fixedToken_attackerCannotMint() public {
        // Attacker tries to mint on fixed token -- should revert
        vm.prank(attacker);
        vm.expectRevert();
        fixedToken.mint(attacker, 1_000_000 * 1e18);

        // Attacker balance should be 0
        assertEq(fixedToken.balanceOf(attacker), 0, "Attacker has no tokens");
    }

    // ---------------------------------------------------------------
    //  Defense: Fixed token -- owner CAN mint
    // ---------------------------------------------------------------

    function test_fixedToken_ownerCanMint() public {
        uint256 supplyBefore = fixedToken.totalSupply();

        vm.prank(deployer);
        fixedToken.mint(alice, 50_000 * 1e18);

        assertEq(fixedToken.balanceOf(alice), 150_000 * 1e18, "Alice got minted tokens");
        assertEq(fixedToken.totalSupply(), supplyBefore + 50_000 * 1e18, "Supply increased");
    }

    // ---------------------------------------------------------------
    //  Defense: Fixed token -- burn only own tokens
    // ---------------------------------------------------------------

    function test_fixedToken_canOnlyBurnOwnTokens() public {
        // Alice burns her own tokens -- should work
        vm.prank(alice);
        fixedToken.burn(50_000 * 1e18);
        assertEq(fixedToken.balanceOf(alice), 50_000 * 1e18, "Alice burned half");
    }

    function test_fixedToken_cannotBurnMoreThanOwned() public {
        // Alice tries to burn more than she has -- should revert
        vm.prank(alice);
        vm.expectRevert();
        fixedToken.burn(200_000 * 1e18);
    }

    // ---------------------------------------------------------------
    //  Ownership
    // ---------------------------------------------------------------

    function test_fixedToken_ownershipCorrect() public view {
        assertEq(fixedToken.owner(), deployer, "Deployer is owner");
    }
}
