---
title: "Scaling Problem"
description: "Проблема масштабирования блокчейнов: blockchain trilemma, throughput limits, scaling approaches"
difficulty: "intermediate"
timeToComplete: 15
---

import { BlockchainTrilemmaDiagram, RollupArchitectureDiagram } from '../../../components/diagrams/Layer2Diagrams';

# The Scaling Problem

Масштабирование — одна из главных проблем блокчейн-индустрии. Ethereum mainnet обрабатывает ~15 TPS (транзакций в секунду). Visa обрабатывает ~65,000 TPS. Разница в 4000 раз. Как масштабировать блокчейн без потери decentralization и security?

Эта проблема не техническая в привычном смысле — увеличить throughput легко: просто добавь больше серверов, увеличь размер блока, ускорь консенсус. Но тогда теряется decentralization. Проблема масштабирования — это **проблема trade-offs**. Каждое решение жертвует чем-то важным.

Для data engineer понимание scaling важно потому что:
- Разные L1 и L2 имеют разную структуру данных и API
- L2 транзакции проходят сложный lifecycle: sequencer → batch → L1 finality
- Анализ cross-chain данных требует понимания, где находится "truth"
- Fee dynamics радикально отличаются между L1 и L2

## Blockchain Trilemma

Vitalik Buterin сформулировал "трилемму блокчейна" — фундаментальное ограничение, с которым сталкивается каждый блокчейн. Три желаемых свойства:

- **Decentralization** — способность запустить ноду на обычном оборудовании, большое количество валидаторов, устойчивость к цензуре
- **Security** — стоимость атаки должна быть астрономически высокой, immutability истории
- **Scalability** — высокий throughput, низкие fees, быстрый finality

<Callout type="note">
Blockchain Trilemma (Vitalik Buterin): невозможно одновременно максимизировать Decentralization, Security и Scalability. Приходится выбирать 2 из 3.
</Callout>

<BlockchainTrilemmaDiagram client:load />

Почему нельзя иметь всё сразу? Потому что **каждая нода должна валидировать каждую транзакцию**. Больше транзакций → больше вычислений → нужно мощнее оборудование → меньше людей могут запустить ноду → меньше decentralization.

### Trade-offs на практике

| Blockchain | TPS | Block Time | Node Requirements | Validators |
|------------|-----|------------|-------------------|------------|
| Bitcoin | 7 | 10 min | 500GB disk | ~15,000 |
| Ethereum L1 | 15-30 | 12 sec | 2TB SSD | ~800,000 |
| Solana | 3,000+ | 400ms | 256GB RAM, 10Gbps | ~2,000 |
| BSC | 300 | 3 sec | High | 21 |

## Почему Ethereum медленный?

Ethereum специально спроектирован медленным — это **design choice**, а не баг. Медленность — цена за decentralization. Разберём три основных bottleneck.

### 1. State Growth

Каждый full node хранит полное состояние сети (World State) и **выполняет каждую транзакцию**. Это fundamental requirement для trustless verification — ты не доверяешь никому, ты сам проверяешь всё.

```
Every node must:
- Store full state (~300GB)
- Execute every transaction
- Validate every state transition

More TPS → More state → Harder to run node → Less decentralization
```

### 2. Block Gas Limit

Block gas limit — это искусственный потолок на количество computation в одном блоке. Зачем он нужен? Чтобы blocks не были слишком большими и propagation по сети был быстрым.

```
Block gas limit: ~30M gas
Simple transfer: ~21,000 gas
ERC20 transfer: ~65,000 gas

Max transfers per block: 30M / 21,000 ≈ 1,400
Blocks per second: 1/12

TPS = 1,400 / 12 ≈ 116 (theoretical max for simple transfers)
TPS = 30M / 65,000 / 12 ≈ 38 (ERC20 transfers)
Real-world mix: ~15-30 TPS
```

### 3. Consensus Overhead

Консенсус требует времени. В PoS Ethereum 800,000+ валидаторов должны "договориться" о состоянии сети. Это координационная проблема, которая не решается просто добавлением железа.

```
PoS Ethereum:
- Slot: 12 seconds
- Epoch: 32 slots = 6.4 minutes
- Finality: 2 epochs ≈ 13 minutes

Faster blocks → More orphans → Less security
```

## Scaling Approaches

Существует три фундаментально разных подхода к масштабированию: vertical (больше ресурсов), horizontal (разделение работы) и layered (вынос computation off-chain). Каждый имеет свои trade-offs.

### Vertical Scaling (Layer 1)

Вертикальное масштабирование — "просто сделай ноды мощнее". Это путь, который выбрали Solana, BSC, и другие "high-performance" L1. Работает, но ценой decentralization.

```
┌─────────────────────────────────────────────────┐
│              Vertical Scaling                    │
├─────────────────────────────────────────────────┤
│ ↑ Bigger blocks                                 │
│ ↑ Faster blocks                                 │
│ ↑ More powerful nodes                           │
├─────────────────────────────────────────────────┤
│ ❌ Reduces decentralization                     │
│ ❌ State grows faster                           │
│ ❌ Higher node requirements                     │
└─────────────────────────────────────────────────┘
```

### Horizontal Scaling (Sharding)

Sharding — разделение state на части (shards), каждый shard обрабатывается отдельно. Это как разделить одну большую базу данных на много маленьких. Изначально Ethereum планировал execution sharding, но этот план был отложен в пользу "rollup-centric" roadmap.

```
┌─────────────────────────────────────────────────┐
│             Sharding (Danksharding)              │
├─────────────────────────────────────────────────┤
│ Split state into multiple "shards"              │
│ Each shard processed in parallel                │
│ Cross-shard communication via beacon chain      │
├─────────────────────────────────────────────────┤
│ ✅ Scales with number of shards                 │
│ ❌ Cross-shard txs complex                      │
│ ❌ Implementation challenging                   │
└─────────────────────────────────────────────────┘
```

### Layer 2 Scaling

Layer 2 — это "умный" подход: вместо изменения L1, мы строим **отдельную систему поверх L1**, которая наследует security от L1, но выполняет транзакции off-chain. Это доминирующий подход сегодня.

```
┌─────────────────────────────────────────────────┐
│               Layer 2 Solutions                  │
├─────────────────────────────────────────────────┤
│ Execute transactions off-chain                  │
│ Post proofs/data to L1                          │
│ Inherit L1 security guarantees                  │
├─────────────────────────────────────────────────┤
│ ✅ Doesn't change L1                            │
│ ✅ Multiple L2s in parallel                     │
│ ✅ Different trade-offs per L2                  │
│ ⚠️  Composability between L2s limited          │
└─────────────────────────────────────────────────┘
```

<Callout type="note">
Ethereum's roadmap: "Rollup-centric" — L1 optimized for data availability, L2s handle execution.
</Callout>

## Layer 2 Categories

История L2 — это эволюция от простых решений к более универсальным. Каждое поколение решало проблемы предыдущего.

### State Channels (поколение 1)

State channels — самый ранний подход к L2. Идея проста: два участника открывают "канал", обмениваются подписанными сообщениями off-chain, и только финальное состояние записывается on-chain.

```
Alice ─────► Channel Contract ◄───── Bob
              │
              │ (off-chain messages)
              ▼
Alice ◄─────────────────────────────► Bob
              │
              │ (final state on-chain)
              ▼
Alice ─────► Channel Contract ◄───── Bob
```

- **Example**: Lightning Network (Bitcoin), Raiden (Ethereum)
- **Pros**: Instant finality, minimal fees
- **Cons**: Requires both parties online, limited use cases

### Plasma (поколение 2)

Plasma (2017) — попытка создать "дочерние цепи", которые периодически публикуют merkle root состояния на L1. Plasma обещала миллионы TPS, но столкнулась с "data availability problem" — если оператор скрывает данные, пользователи не могут доказать свои права.

```
L1 (Ethereum)
    │
    └──► Plasma Contract
              │
              ▼
        Plasma Chain (operator)
              │
         ┌────┴────┐
         │         │
       Block     Block
       [txs]     [txs]
              │
              ▼
         Merkle Root → L1
```

- **Pros**: High throughput
- **Cons**: Exit games complex, data availability issues

### Rollups (поколение 3 — текущий стандарт)

Rollups — это решение Plasma's data availability problem. Ключевое отличие: rollups публикуют **все данные транзакций** на L1, а не только state root. Это делает систему trustless — любой может верифицировать состояние.

<RollupArchitectureDiagram client:load />

Два типа rollups отличаются способом гарантии валидности:

- **Optimistic Rollups**: предполагают, что всё честно. Есть "challenge period" (7 дней), в течение которого любой может доказать fraud. Arbitrum, Optimism, Base.
- **ZK Rollups**: каждый batch сопровождается криптографическим доказательством валидности. Нет challenge period — finality сразу после proof verification. zkSync, Polygon zkEVM, Scroll.

## Current L2 Landscape

| L2 | Type | TPS | Finality | TVL |
|----|------|-----|----------|-----|
| Arbitrum One | Optimistic | ~40 | 7 days* | $10B+ |
| Optimism | Optimistic | ~30 | 7 days* | $7B+ |
| Base | Optimistic | ~30 | 7 days* | $5B+ |
| zkSync Era | ZK | ~100 | Minutes | $500M+ |
| Polygon zkEVM | ZK | ~50 | Minutes | $100M+ |
| Linea | ZK | ~50 | Minutes | $300M+ |

*7 days = challenge period for fraud proofs. Practical finality faster with sequencer confirmation.

## Данные для анализа

```sql
-- L2 activity comparison
SELECT
    chain,
    DATE(block_timestamp) as date,
    COUNT(*) as tx_count,
    COUNT(DISTINCT from_address) as unique_users,
    SUM(gas_used * gas_price) / 1e18 as total_fees_eth
FROM multi_chain.transactions
WHERE chain IN ('arbitrum', 'optimism', 'base', 'zksync')
  AND block_timestamp > '2024-01-01'
GROUP BY chain, DATE(block_timestamp)
ORDER BY date DESC, tx_count DESC;
```

## Резюме

- Blockchain trilemma: trade-off между decentralization, security, scalability
- Ethereum L1: ~15-30 TPS, limited by state growth и gas limit
- L2 solutions: execute off-chain, inherit L1 security
- Rollups — доминирующий подход: Optimistic (fraud proofs) vs ZK (validity proofs)
- "Rollup-centric" roadmap: L1 для data availability, L2 для execution
