---
title: "ZK Rollups"
description: "Zero-Knowledge Rollups: validity proofs, SNARKs vs STARKs, zkEVM"
difficulty: "advanced"
timeToComplete: 25
---

# ZK Rollups

ZK Rollups представляют "следующее поколение" L2 scaling. Вместо fraud proofs (докажи, что неверно) они используют **validity proofs** (докажи, что верно). Каждый batch сопровождается криптографическим доказательством, которое **математически гарантирует** корректность всех транзакций.

Почему ZK — это важно? Потому что validity proofs решают две главные проблемы Optimistic rollups:
- **Нет 7-дневного challenge period** — finality за минуты, не дни
- **Нет trust assumptions** — proof либо валиден, либо нет. Нет "optimistic" предположений

Цена? ZK rollups **значительно сложнее** в разработке. Proof generation требует огромных вычислительных ресурсов. EVM не был спроектирован для ZK, и создание zkEVM — это монументальная инженерная задача.

Для data engineer ZK rollups интересны тем, что:
- Proof submissions на L1 содержат уникальные данные (proof size, verification gas)
- Finality model проще — нет distinction между "soft" и "hard" finality
- Разные zkEVM types имеют разную совместимость с EVM

## Optimistic vs ZK

<Callout type="note">
Optimistic: "Докажи, что я неправ" (7 дней на challenge)
ZK: "Вот доказательство, что я прав" (мгновенная верификация)
</Callout>

| Aspect | Optimistic | ZK |
|--------|------------|-----|
| Validity | Assumed (fraud proofs) | Proven (validity proofs) |
| Finality | 7 days | Minutes (proof generation) |
| Withdrawal | 7 days | Fast |
| Computation | Cheap (off-chain) | Expensive (proof generation) |
| EVM compatibility | Native | Challenging |

## Zero-Knowledge Proofs

Zero-Knowledge Proofs — одно из самых мощных криптографических изобретений последних десятилетий. Концепция появилась в 1985 году (Goldwasser, Micali, Rackoff), но практическое применение стало возможным только недавно.

### Что такое ZK Proof?

ZK Proof позволяет **доказать знание чего-то, не раскрывая само знание**. Классическая аналогия: ты знаешь пароль от сейфа. Вместо того чтобы показать пароль, ты открываешь сейф — это доказывает знание без раскрытия.

```
Prover                              Verifier
   │                                    │
   │  "I know x such that f(x) = y"     │
   │ ──────────────────────────────────►│
   │                                    │
   │  Proof π (doesn't reveal x)        │
   │ ──────────────────────────────────►│
   │                                    │
   │                              Verify(π, y) = true/false
   │                                    │
```

Свойства:
- **Completeness**: честный prover всегда убедит
- **Soundness**: нечестный prover не может обмануть
- **Zero-Knowledge**: verifier не узнаёт x (только что proof валиден)

### SNARKs vs STARKs

Два основных семейства ZK proofs с разными trade-offs:

- **SNARKs** (Succinct Non-interactive ARguments of Knowledge) — маленькие proofs, быстрая verification, но требуют "trusted setup"
- **STARKs** (Scalable Transparent ARguments of Knowledge) — большие proofs, но transparent (нет trusted setup) и quantum-resistant

| Property | SNARKs | STARKs |
|----------|--------|--------|
| Trusted Setup | Required | Not required |
| Proof Size | ~200 bytes | ~50 KB |
| Verification | O(1) | O(log n) |
| Quantum Resistant | No | Yes |
| Prover Time | Faster | Slower |
| Used by | zkSync, Polygon zkEVM | StarkNet, zkSync (hybrid) |

## ZK Rollup Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                      ZK Rollup                               │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   Users ──► Sequencer ──► Prover ──► L1 Verifier            │
│      │          │            │            │                 │
│      │    ┌─────┴────┐  ┌────┴────┐      │                 │
│      │    │          │  │         │      │                 │
│      │  Order &    Batch  Generate      │                 │
│      │  Execute    txs    ZK Proof      │                 │
│      │    │          │  │         │      │                 │
│      │    └────┬─────┘  └────┬────┘      │                 │
│      │         │             │           │                 │
│      │         └──────┬──────┘           │                 │
│      │                │                  │                 │
│      │    State Root + Proof + Tx Data   │                 │
│      │                │                  │                 │
│      │                ▼                  │                 │
│      │        ┌───────────────┐          │                 │
│      │        │  L1 Verifier  │ ◄────────┘                 │
│      │        │  Contract     │                            │
│      │        └───────────────┘                            │
│      │                │                                    │
│      │    Verification: O(1) computation                   │
│      │    If valid → State finalized                       │
│      │                                                     │
└─────────────────────────────────────────────────────────────┘
```

## zkEVM

zkEVM — "святой грааль" ZK rollups: EVM, execution которого можно доказать с помощью ZK proofs. Проблема в том, что EVM был спроектирован в 2013-2014 годах **без учёта ZK**. Многие opcodes (KECCAK256, например) крайне дороги в ZK circuits.

<Callout type="warning">
EVM не был разработан для ZK. Доказательство EVM execution — сложная инженерная задача.
</Callout>

Vitalik Buterin предложил классификацию zkEVM по уровню совместимости с Ethereum. Чем выше совместимость, тем сложнее и медленнее proof generation.

### zkEVM Types (Vitalik's classification)

```
┌────────────────────────────────────────────────────────────┐
│                    zkEVM Spectrum                           │
├────────────────────────────────────────────────────────────┤
│                                                            │
│  Type 1: Fully Ethereum-equivalent                         │
│  ├─ Proves actual Ethereum blocks                          │
│  ├─ No modifications to Ethereum                           │
│  └─ Examples: (in development)                             │
│                                                            │
│  Type 2: Fully EVM-equivalent                              │
│  ├─ Same EVM, different state/block structure              │
│  ├─ 100% Solidity compatible                               │
│  └─ Examples: Scroll, Polygon zkEVM                        │
│                                                            │
│  Type 2.5: EVM-equivalent except gas costs                 │
│  ├─ Different gas costs for some opcodes                   │
│  └─ Examples: Scroll (current)                             │
│                                                            │
│  Type 3: Almost EVM-equivalent                             │
│  ├─ Most contracts work                                    │
│  ├─ Some edge cases differ                                 │
│  └─ Examples: (transitional)                               │
│                                                            │
│  Type 4: High-level language equivalent                    │
│  ├─ Compiles Solidity/Vyper to ZK-friendly VM              │
│  ├─ Different bytecode                                     │
│  └─ Examples: zkSync Era, StarkNet (Cairo)                 │
│                                                            │
│                                                            │
│  ◄────────────────────────────────────────────────────────►│
│  More compatible                              Faster proofs │
└────────────────────────────────────────────────────────────┘
```

### zkSync Era (Type 4)

```
Solidity/Vyper
      │
      ▼
   zksolc/zkvyper (custom compiler)
      │
      ▼
   zkEVM bytecode (not EVM bytecode!)
      │
      ▼
   zkSync VM execution
      │
      ▼
   SNARK proof generation
```

### Polygon zkEVM (Type 2)

```
Solidity
      │
      ▼
   Standard solc
      │
      ▼
   EVM bytecode
      │
      ▼
   zkEVM execution (circuit per opcode)
      │
      ▼
   SNARK proof generation
```

## Proof Generation

Proof generation — самая ресурсоёмкая часть ZK rollups. Prover должен взять batch транзакций и сгенерировать proof, который можно верифицировать за O(1) time on-chain. Это **асимметрия**: generation занимает минуты-часы и требует GPU кластеров, verification — миллисекунды и ~500K gas.

### Prover Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                   Prover Pipeline                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Transactions                                               │
│       │                                                     │
│       ▼                                                     │
│  ┌───────────┐                                             │
│  │ Execution │ → Execution trace                           │
│  │   Trace   │   (every opcode, memory, storage access)    │
│  └───────────┘                                             │
│       │                                                     │
│       ▼                                                     │
│  ┌───────────┐                                             │
│  │ Arithmetic│ → Constraints (polynomial equations)        │
│  │  Circuit  │   R1CS / AIR                                │
│  └───────────┘                                             │
│       │                                                     │
│       ▼                                                     │
│  ┌───────────┐                                             │
│  │   Prover  │ → ZK Proof                                  │
│  │  (heavy)  │   SNARK / STARK                             │
│  └───────────┘                                             │
│       │                                                     │
│  Compute: GPU cluster, minutes-hours                        │
│  Memory: 100+ GB RAM                                        │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Proof Aggregation

```
Batch 1 ──► Proof 1 ─┐
Batch 2 ──► Proof 2 ─┼──► Aggregated Proof ──► L1
Batch 3 ──► Proof 3 ─┘

Benefit: One L1 verification for multiple batches
         Amortizes verification cost
```

## Current ZK Rollups

| Rollup | Type | Proof System | TVL | Status |
|--------|------|--------------|-----|--------|
| zkSync Era | Type 4 | PLONK + FRI | $150M | Mainnet |
| Polygon zkEVM | Type 2 | SNARK | $50M | Mainnet |
| Scroll | Type 2.5 | SNARK | $100M | Mainnet |
| Linea | Type 2 | SNARK | $300M | Mainnet |
| StarkNet | Type 4 (Cairo) | STARK | $200M | Mainnet |

## Data для анализа

```sql
-- zkSync Era proof submissions
SELECT
    block_number,
    transaction_hash,
    gas_used as verification_gas,
    -- Proof data in input
    LENGTH(input) as proof_size_bytes
FROM ethereum.transactions
WHERE to_address = '0x32400084C286CF3E17e7B677ea9583e60a000324'  -- zkSync diamond
  AND SUBSTR(input, 1, 10) = '0x...'  -- proveBlocks selector
ORDER BY block_number DESC
LIMIT 50;

-- Compare L2 activity
SELECT
    chain,
    COUNT(*) as tx_count,
    COUNT(DISTINCT from_address) as users,
    AVG(gas_price) / 1e9 as avg_gwei
FROM l2_transactions
WHERE chain IN ('zksync', 'polygon_zkevm', 'scroll', 'linea')
  AND block_timestamp > CURRENT_DATE - INTERVAL '7 days'
GROUP BY chain
ORDER BY tx_count DESC;
```

## Резюме

- ZK Rollups: validity proofs вместо fraud proofs
- Finality: минуты (proof generation) вместо 7 дней
- SNARKs: маленькие proofs, требуют trusted setup
- STARKs: большие proofs, quantum-resistant
- zkEVM types: Type 1-4, trade-off compatibility vs prover speed
- Proof generation: GPU-intensive, minutes-hours per batch
- Aggregation: один proof для нескольких batches
