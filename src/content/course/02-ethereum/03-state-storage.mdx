---
title: "State & Storage"
description: "Управление состоянием в Ethereum: Account State, Contract Storage, State Trie"
difficulty: "intermediate"
timeToComplete: 20
---

# State & Storage

State management — ключевая особенность Ethereum. В отличие от Bitcoin (stateless UTXO), Ethereum хранит полное состояние всех аккаунтов и контрактов.

## Account State

<Callout type="info">
World State = глобальное состояние всех аккаунтов. Изменяется с каждым блоком.
</Callout>

### Account Fields

```python
class AccountState:
    nonce: uint64      # Счётчик (tx для EOA, creates для Contract)
    balance: uint256   # Wei (10^18 Wei = 1 ETH)
    storage_root: Hash # Merkle root storage trie (contracts only)
    code_hash: Hash    # keccak256(bytecode) (contracts only)

# EOA
alice = AccountState(
    nonce=42,
    balance=1_500_000_000_000_000_000,  # 1.5 ETH
    storage_root=EMPTY_ROOT,
    code_hash=EMPTY_CODE_HASH
)

# Contract
uniswap = AccountState(
    nonce=1,  # Created 1 child contract
    balance=0,
    storage_root="0x8a9c...",
    code_hash="0x3f2b..."
)
```

## Contract Storage

Storage — persistent key-value store для контрактов:

```
Storage = Map<uint256, uint256>
Key:   32 bytes (slot number)
Value: 32 bytes
```

### Storage Layout

```solidity
contract Example {
    // Slot 0
    uint256 public totalSupply;

    // Slot 1
    address public owner;  // 20 bytes, остальные 12 bytes пусты

    // Slot 2
    uint128 public a;  // Первые 16 bytes
    uint128 public b;  // Последние 16 bytes (packed!)

    // Slot 3 = keccak256(3) для dynamic array length
    uint256[] public values;

    // Slot 4 = начало mapping
    // Actual location: keccak256(key . 4)
    mapping(address => uint256) public balances;
}
```

### Вычисление Storage Slots

```python
import hashlib

def keccak256(data: bytes) -> bytes:
    from Crypto.Hash import keccak
    return keccak.new(data=data, digest_bits=256).digest()

# Simple variable
slot_0 = 0  # totalSupply

# Array element
# values[i] located at: keccak256(slot) + i
array_slot = 3
array_start = int.from_bytes(keccak256(array_slot.to_bytes(32, 'big')), 'big')
values_0_slot = array_start + 0
values_1_slot = array_start + 1

# Mapping value
# balances[addr] located at: keccak256(addr . slot)
mapping_slot = 4
addr = bytes.fromhex("742d35Cc6634C0532925a3b844Bc454e4438f44E")
key_data = addr.rjust(32, b'\x00') + mapping_slot.to_bytes(32, 'big')
balance_slot = keccak256(key_data)
```

### Nested Mappings

```solidity
// mapping(address => mapping(address => uint256)) allowance
// Slot: 5

// allowance[owner][spender]
// Location: keccak256(spender . keccak256(owner . 5))
```

## State Trie

Ethereum использует Modified Merkle Patricia Trie:

```
                    State Root
                        │
        ┌───────────────┴───────────────┐
        │                               │
    Extension                       Extension
    [shared prefix]                 [shared prefix]
        │                               │
    ┌───┴───┐                       ┌───┴───┐
  Branch   Branch                 Branch   Branch
    │         │                     │         │
  Leaf      Leaf                  Leaf      Leaf
  [Account] [Account]            [Account] [Account]
```

### Trie Types

| Trie | Key | Value | Updates |
|------|-----|-------|---------|
| State Trie | keccak256(address) | RLP(account) | Every block |
| Storage Trie | keccak256(slot) | RLP(value) | On writes |
| Transaction Trie | RLP(tx_index) | RLP(tx) | Per block |
| Receipt Trie | RLP(tx_index) | RLP(receipt) | Per block |

<Callout type="warning">
State Trie содержит ~300M аккаунтов. Полная синхронизация = ~1TB. Snap sync = ~500GB.
</Callout>

## State Growth Problem

### Размер State

```
Year    Accounts    State Size
2016    1M          ~1GB
2018    50M         ~50GB
2020    100M        ~100GB
2024    300M        ~300GB+ (с history)
```

### EIP-4844: State Expiry (планируется)

```
Проблема: State растёт бесконечно, даже "мёртвые" аккаунты занимают место

Решение (предложение):
1. State разделяется на "epochs" (~1 год)
2. Неиспользуемые данные "expire" (удаляются из active state)
3. Witness proofs позволяют восстановить expired state
```

## Storage в Data Engineering

### Прямое чтение Storage

```python
from web3 import Web3

w3 = Web3(Web3.HTTPProvider('https://eth-mainnet.g.alchemy.com/v2/...'))

# Читаем slot 0 контракта USDC
usdc = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"
total_supply = w3.eth.get_storage_at(usdc, 0)
print(f"Total supply slot: {total_supply.hex()}")

# Читаем баланс конкретного адреса
# USDC balances mapping at slot 9
holder = "0x47ac0Fb4F2D84898e4D9E7b4DaB3C24507a6D503"  # Binance
slot = Web3.solidity_keccak(
    ['address', 'uint256'],
    [holder, 9]
)
balance = w3.eth.get_storage_at(usdc, slot)
print(f"Binance USDC balance: {int.from_bytes(balance, 'big') / 1e6}")
```

### State Queries

```sql
-- Анализ state через Archive Node API
-- (обычно через специальные indexers типа Dune, Flipside)

-- Top holders по прямому чтению storage
SELECT
    address,
    eth_call_balance(address) / 1e18 as eth_balance
FROM ethereum.addresses
WHERE eth_call_balance(address) > 0
ORDER BY eth_balance DESC
LIMIT 100;

-- Contract storage analysis
SELECT
    contract_address,
    slot,
    hex(value) as value_hex,
    block_number
FROM ethereum.storage_diffs
WHERE contract_address = '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48'
  AND slot = '0x0'  -- totalSupply
ORDER BY block_number DESC;
```

## State Diff vs Full State

### State Diff (более эффективно)

```python
# State diff = изменения между блоками
state_diff = {
    "block": 18500000,
    "changes": [
        {
            "address": "0x742d...",
            "balance_before": 1500000000000000000,
            "balance_after": 1400000000000000000,
            "nonce_before": 42,
            "nonce_after": 43,
        },
        {
            "address": "0xa0b8...",  # USDC
            "storage": {
                "0x3f2b...": {  # balances[sender]
                    "before": "0x000...0100",
                    "after": "0x000...0050"
                },
                "0x8c1a...": {  # balances[recipient]
                    "before": "0x000...0000",
                    "after": "0x000...00b0"
                }
            }
        }
    ]
}
```

### Практическое применение

```sql
-- Таблица state diffs (Dune Analytics style)
CREATE TABLE state_diffs (
    block_number BIGINT,
    transaction_index INT,
    address CHAR(42),

    -- Account changes
    balance_before NUMERIC(78),
    balance_after NUMERIC(78),
    nonce_before INT,
    nonce_after INT,

    -- Storage changes
    storage_key CHAR(66),
    storage_value_before CHAR(66),
    storage_value_after CHAR(66)
);

-- Найти все изменения баланса USDC
SELECT
    block_number,
    storage_key as holder_slot,
    storage_value_before,
    storage_value_after
FROM state_diffs
WHERE address = '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48'
  AND storage_key IS NOT NULL
ORDER BY block_number DESC;
```

## Резюме

- World State = Map<Address, Account>
- Contract Storage = Map<uint256, uint256> (slot → value)
- Storage layout: fixed slots + dynamic (keccak256 для arrays/mappings)
- State Trie = Modified Merkle Patricia Trie (~300GB)
- State diff более эффективен для analytics чем full state
- Прямое чтение storage через eth_getStorageAt или Archive Nodes
