---
title: "EVM & Gas"
description: "Ethereum Virtual Machine: opcodes, execution model, gas metering"
difficulty: "intermediate"
timeToComplete: 25
---

import { EVMExecutionDiagram, GasModelDiagram } from '../../../components/diagrams/EthereumDiagrams';

# EVM & Gas

EVM (Ethereum Virtual Machine) — виртуальная машина, которая выполняет smart contracts. Понимание EVM критично для оптимизации запросов и понимания gas costs.

## EVM Overview

<Callout type="note">
EVM — stack-based виртуальная машина с 256-bit словами. Каждая операция потребляет gas.
</Callout>

<EVMExecutionDiagram client:load />

### Характеристики

| Параметр | Значение |
|----------|----------|
| Word size | 256 bits |
| Stack depth | 1024 |
| Memory | Byte-addressable, expandable |
| Storage | Key-value (256-bit → 256-bit) |
| Call depth | Max 1024 |

### Execution Context

```python
class ExecutionContext:
    # Immutable
    address: Address         # Текущий контракт
    caller: Address          # Кто вызвал (msg.sender)
    origin: Address          # Начальный sender (tx.origin)
    call_value: int          # ETH переданный (msg.value)
    call_data: bytes         # Input data
    gas_price: int

    # Mutable
    gas_remaining: int
    program_counter: int
    stack: List[int]         # Max 1024 elements
    memory: bytes            # Expandable
    storage: Dict[int, int]  # Persistent
    return_data: bytes
```

## Opcodes

EVM имеет ~140 opcodes. Ключевые категории:

### Arithmetic

```
ADD, SUB, MUL, DIV, MOD     (3 gas)
EXP                          (10 + 50 * byte_size gas)
```

### Stack Operations

```
PUSH1-PUSH32  (3 gas)   # Push 1-32 bytes
POP           (2 gas)
DUP1-DUP16    (3 gas)   # Duplicate stack item
SWAP1-SWAP16  (3 gas)   # Swap stack items
```

### Memory

```
MLOAD   (3 gas)         # Load 32 bytes from memory
MSTORE  (3 gas)         # Store 32 bytes to memory
MSTORE8 (3 gas)         # Store 1 byte
```

### Storage (самые дорогие!)

```
SLOAD   (100-2100 gas)  # Read from storage
SSTORE  (100-20000 gas) # Write to storage

# Cold access: первое чтение slot = 2100 gas
# Warm access: повторное чтение = 100 gas
# Write 0→non-zero: 20000 gas
# Write non-zero→non-zero: 2900 gas
# Write non-zero→0: 2900 gas + 4800 refund
```

<Callout type="warning">
Storage operations — главная причина высоких gas costs. Один SSTORE может стоить 20,000 gas = ~$2-5 при высоком gas price.
</Callout>

### Control Flow

```
JUMP      (8 gas)
JUMPI     (10 gas)      # Conditional jump
STOP      (0 gas)
RETURN    (0 gas)
REVERT    (0 gas)       # Revert with data
```

### External Calls

```
CALL          (100-9000 gas + memory expansion)
DELEGATECALL  (100-9000 gas)  # Runs in caller context
STATICCALL    (100-9000 gas)  # Read-only
CREATE        (32000 gas)     # Deploy contract
CREATE2       (32000 gas)     # Deploy with salt
```

## Gas Model

<GasModelDiagram client:load />

### Base Formula

```
transaction_cost = base_cost + execution_cost

base_cost = 21000 (simple transfer)
          + 16 * non_zero_calldata_bytes
          + 4 * zero_calldata_bytes
          + 32000 (if contract creation)
```

### EIP-1559 Fee Model

```
┌─────────────────────────────────────────────────┐
│           EIP-1559 Fee Structure                │
├─────────────────────────────────────────────────┤
│                                                 │
│  max_fee = max_priority_fee + base_fee          │
│                                                 │
│  ┌─────────────────┐                           │
│  │ Priority Fee    │ → Validator (tip)          │
│  │ (max_priority)  │                           │
│  ├─────────────────┤                           │
│  │ Base Fee        │ → BURNED                   │
│  │ (protocol)      │                           │
│  └─────────────────┘                           │
│                                                 │
│  actual_fee = gas_used * (base_fee + tip)       │
│  refund = (max_fee - actual) * gas_used         │
└─────────────────────────────────────────────────┘
```

### Base Fee Adjustment

```python
def calculate_next_base_fee(parent_block):
    target_gas = parent_block.gas_limit // 2

    if parent_block.gas_used == target_gas:
        return parent_block.base_fee
    elif parent_block.gas_used > target_gas:
        # Increase up to 12.5%
        delta = parent_block.base_fee * (gas_used - target) // target // 8
        return parent_block.base_fee + max(delta, 1)
    else:
        # Decrease up to 12.5%
        delta = parent_block.base_fee * (target - gas_used) // target // 8
        return parent_block.base_fee - delta
```

## Memory Expansion

Memory expandable, но стоимость растёт квадратично:

```python
def memory_cost(size_words):
    return 3 * size_words + size_words ** 2 // 512

# Примеры:
# 32 bytes (1 word): 3 gas
# 1 KB (32 words): 98 gas
# 1 MB (32768 words): 2,195,456 gas (~$50-100!)
```

<Callout type="note">
Копирование больших данных в memory — частая причина out-of-gas. Лимит практически ~30KB для одной транзакции.
</Callout>

## Execution Trace

```python
# Пример: Simple transfer trace
def trace_transfer():
    """
    Contract: ERC20
    Function: transfer(to, amount)
    """
    opcodes = [
        # Function selector check
        ("PUSH4", "0xa9059cbb", 3),      # transfer(address,uint256)
        ("EQ", None, 3),
        ("JUMPI", "transfer_start", 10),

        # Load balances[msg.sender]
        ("CALLER", None, 2),
        ("PUSH1", "0x00", 3),             # balances mapping slot
        ("SLOAD", None, 2100),            # Cold read: 2100 gas!

        # Check balance >= amount
        ("DUP2", None, 3),
        ("GT", None, 3),
        ("JUMPI", "insufficient", 10),

        # Update sender balance
        ("SUB", None, 3),
        ("SSTORE", None, 2900),           # Warm write

        # Update recipient balance
        ("SLOAD", None, 2100),            # Cold read
        ("ADD", None, 3),
        ("SSTORE", None, 20000),          # 0 → non-zero!

        # Emit Transfer event
        ("LOG3", None, 1500),             # 375 + 375*3 topics

        ("RETURN", None, 0),
    ]

    total_gas = 21000  # Base
    total_gas += sum(op[2] for op in opcodes)
    return total_gas  # ~50,000 gas

# Реальный ERC20 transfer: 40,000-65,000 gas
```

## Gas Optimization Patterns

### 1. Batch Operations

```solidity
// Bad: N transactions
for (uint i = 0; i < recipients.length; i++) {
    token.transfer(recipients[i], amounts[i]);
}
// Cost: N * 65,000 = 650,000 gas for 10 transfers

// Good: 1 transaction with batch
token.batchTransfer(recipients, amounts);
// Cost: ~200,000 gas for 10 transfers (saves 70%)
```

### 2. Storage Packing

```solidity
// Bad: 3 slots
struct UserBad {
    uint256 id;        // slot 0
    uint256 balance;   // slot 1
    uint256 timestamp; // slot 2
}

// Good: 1 slot
struct UserGood {
    uint128 balance;   // slot 0 (first half)
    uint64 id;         // slot 0 (packed)
    uint64 timestamp;  // slot 0 (packed)
}
```

### 3. Use Events Instead of Storage

```solidity
// Bad: Store all data
mapping(uint => Order) public orders;

// Good: Emit events, reconstruct off-chain
event OrderCreated(uint indexed orderId, address indexed user, uint amount);
```

## Данные для анализа

```sql
-- Gas usage analysis
SELECT
    DATE(block_timestamp) as date,
    AVG(gas_price) / 1e9 as avg_gwei,
    AVG(gas_used) as avg_gas_used,
    SUM(gas_used * gas_price) / 1e18 as total_eth_burned
FROM ethereum.transactions
WHERE block_timestamp > '2024-01-01'
GROUP BY DATE(block_timestamp);

-- Most gas-consuming contracts
SELECT
    to_address as contract,
    COUNT(*) as tx_count,
    SUM(gas_used) as total_gas,
    AVG(gas_used) as avg_gas
FROM ethereum.transactions
WHERE to_address IS NOT NULL
GROUP BY to_address
ORDER BY total_gas DESC
LIMIT 20;
```

## Резюме

- EVM — stack-based VM с 256-bit словами
- Storage ops (SLOAD/SSTORE) — самые дорогие (100-20,000 gas)
- EIP-1559: base_fee (burned) + priority_fee (validator)
- Memory expansion cost растёт квадратично
- Gas optimization: batching, storage packing, events vs storage
- Типичный ERC20 transfer: 40,000-65,000 gas
