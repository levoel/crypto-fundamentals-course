---
title: "Майнинг и Proof of Work"
description: "Как майнеры находят блоки — алгоритм Proof of Work, nonce и хеш ниже цели"
order: 6
difficulty: "intermediate"
estimatedTime: 25
topics: ["Майнинг", "Proof of Work", "Nonce", "SHA-256d", "Блок", "Target"]
prerequisites: ["03-block-structure"]
---

import { MiningSimulator, HashTargetVisualization } from '../../../components/diagrams/module2/MiningDiagrams';

# Майнинг и Proof of Work

## Зачем это блокчейну?

Каждые ~10 минут один из тысяч майнеров находит число (nonce), при котором хеш заголовка блока оказывается меньше определённой цели. Это **Proof of Work** -- вычислительная лотерея, обеспечивающая безопасность Bitcoin. Без неё любой мог бы добавить произвольный блок в цепочку, отменить транзакции или потратить монеты дважды.

```python
# Суть майнинга в 5 строках:
import hashlib
header = b"version|prev_hash|merkle_root|timestamp|bits|nonce"
hash_result = hashlib.sha256(hashlib.sha256(header).digest()).digest()
target = 0x00000000FFFF0000000000000000000000000000000000000000000000000000
print("Блок найден!" if int.from_bytes(hash_result, 'big') < target else "Пробуем снова...")
```

## Интуитивное объяснение: лотерея с костями

Представьте, что вам нужно бросить 100-гранную кость и выбросить число **меньше 5**. Вероятность -- 4/100 = 4%. В среднем придётся бросить кость ~25 раз.

Теперь усложним: нужно выбросить число **меньше 2**. Вероятность -- 1/100 = 1%. Придётся бросить ~100 раз.

**Proof of Work -- это бросание хеш-костей:**
- Кость -- это SHA-256 от заголовка блока
- «Выбросить число меньше N» -- это найти хеш меньше target
- Единственный способ повлиять на результат -- менять nonce и пересчитывать хеш
- Чем ниже target (выше сложность), тем больше попыток нужно

Никакой «хитрости» нет -- только перебор. Это и есть **доказательство работы**: чтобы найти блок, майнер доказывает, что совершил огромное количество вычислений.

## Алгоритм майнинга

```
while true:
    header = version + prev_hash + merkle_root + timestamp + bits + nonce
    hash = SHA256(SHA256(header))     # двойной SHA-256
    if hash < target:
        Блок найден! Рассылаем по сети.
        break
    nonce += 1
    if nonce > 2^32:
        Обновить timestamp / транзакции / extraNonce
```

Ключевые моменты:
1. **Двойной SHA-256** (SHA-256d) -- хеш от хеша. Защита от атак length-extension.
2. **80 байт заголовка** -- вычисляется хеш только от заголовка, не от всего блока.
3. **Детерминизм** -- один и тот же заголовок всегда даёт один и тот же хеш.
4. **Лавинный эффект** -- изменение nonce на 1 полностью меняет хеш (вспомните CRYPTO-03).

## Симулятор майнинга

Попробуйте найти блок вручную! Нажмите «+1 Nonce» или запустите автоматический майнинг:

<MiningSimulator client:load />

Что заметили?
- При сложности 1 (один ведущий ноль) блок находится быстро -- за ~16 попыток в среднем
- При сложности 2 -- за ~256 попыток
- Каждый дополнительный ноль увеличивает сложность в 16 раз

## Хеш ниже цели: визуализация

Представьте все возможные 256-битные числа как отрезок от 0 до 2^256. Target делит этот отрезок: хеши левее target (зелёная зона) -- валидные блоки, правее (красная) -- невалидные.

<HashTargetVisualization client:visible />

Чем ниже target, тем уже зелёная зона и тем труднее «попасть» в неё случайным хешем. Вероятность нахождения валидного блока за одну попытку:

```
P = target / 2^256
```

## Что если nonce переполнится?

Поле nonce в заголовке блока -- всего 4 байта (2^32 = ~4.3 миллиарда значений). Современные ASIC-майнеры перебирают все 4 миллиарда за доли секунды. Что делать дальше?

1. **Extra Nonce в coinbase-транзакции** -- майнер меняет данные coinbase-транзакции, что меняет Merkle root (а значит, и весь заголовок).
2. **Timestamp** -- допустимо варьировать на несколько секунд.
3. **Порядок транзакций** -- изменение порядка меняет Merkle root.

Фактически, пространство поиска бесконечно -- nonce лишь один из параметров.

## Блок-награда и Halving

Майнер, нашедший блок, получает **блок-награду** (block subsidy) -- новые монеты, которых раньше не существовало. Это единственный способ эмиссии Bitcoin.

| Период | Блоки | Награда | Годы |
|--------|-------|---------|------|
| 1 | 0 -- 209 999 | 50 BTC | 2009--2012 |
| 2 | 210 000 -- 419 999 | 25 BTC | 2012--2016 |
| 3 | 420 000 -- 629 999 | 12.5 BTC | 2016--2020 |
| 4 | 630 000 -- 839 999 | 6.25 BTC | 2020--2024 |
| 5 | 840 000 -- ... | 3.125 BTC | 2024--~2028 |

Каждые 210 000 блоков (~4 года) награда уменьшается вдвое -- это **halving**. Геометрическая прогрессия гарантирует, что всего будет создано ~21 миллион BTC. Последний сатоши будет намайнен примерно в 2140 году.

Помимо блок-награды, майнер получает **комиссии** (fees) со всех включённых в блок транзакций.

## Математический уровень

### Ожидаемое количество хешей

Если target задаёт вероятность `p = target / 2^256` нахождения блока за одну попытку, то ожидаемое количество попыток:

```
E[hashes] = 1/p = 2^256 / target
```

### Хешрейт

Скорость перебора хешей измеряется в хешах в секунду:
- **TH/s** = 10^12 хешей/с (террахеш)
- **PH/s** = 10^15 хешей/с (петахеш)
- **EH/s** = 10^18 хешей/с (эксахеш)

Глобальный хешрейт сети Bitcoin в 2025 году -- порядка 600--800 EH/s.

### Среднее время нахождения блока

```
t_avg = E[hashes] / hashrate = 2^256 / (target * hashrate)
```

Сеть подстраивает target так, чтобы `t_avg ≈ 600 секунд` (10 минут).

## Связь с SHA-256

Proof of Work работает **благодаря** свойствам хеш-функций, которые мы изучали в Phase 1:

1. **Устойчивость к прообразу** (CRYPTO-03): невозможно вычислить nonce, дающий нужный хеш, кроме перебора.
2. **Лавинный эффект** (CRYPTO-03): изменение одного бита nonce полностью меняет хеш -- нельзя «приблизиться» к цели постепенно.
3. **Равномерное распределение** (CRYPTO-04): хеши распределены равномерно, поэтому каждая попытка -- независимый эксперимент с фиксированной вероятностью.

Без этих свойств PoW был бы бесполезен: если бы можно было «угадывать» nonce, вычислительная лотерея не работала бы.

## Практика

Реализуйте майнинг в Python, постройте Genesis-блок и исследуйте зависимость числа попыток от сложности:

Notebook: `labs/crypto/notebooks/12-bitcoin-mining.ipynb`

## Что дальше?

Мы увидели, что сложность (target) определяет, сколько вычислительной работы нужно для нахождения блока. Но кто и как меняет target? В следующем уроке разберём **механизм автоматической корректировки сложности** -- самонастраивающийся алгоритм, который поддерживает 10-минутный интервал между блоками.
