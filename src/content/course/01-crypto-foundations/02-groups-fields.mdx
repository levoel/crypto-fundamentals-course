---
title: "Группы и конечные поля"
description: "Абстрактная алгебра для криптографии — группы, кольца, поля"
order: 2
difficulty: "intermediate"
estimatedTime: 25
topics: ["Groups", "Finite Fields", "Abstract Algebra", "Galois Fields"]
---

import { GroupStructureDiagram, FieldOperationsDiagram } from '../../../components/diagrams/module1';

# Группы и конечные поля

## Зачем абстрактная алгебра?

В предыдущем уроке мы работали с модулярной арифметикой интуитивно. Теперь формализуем эти понятия через **алгебраические структуры** — это язык, на котором описывается криптография.

> **Почему это важно:** Эллиптические кривые (основа Bitcoin и Ethereum) работают над конечными полями. Без понимания полей невозможно понять, как работают цифровые подписи.

## Группа

**Группа** — это множество G с операцией ∘, удовлетворяющей четырем аксиомам:

### 1. Замкнутость
Для любых a, b ∈ G: a ∘ b ∈ G

### 2. Ассоциативность
(a ∘ b) ∘ c = a ∘ (b ∘ c)

### 3. Нейтральный элемент
Существует e ∈ G такой, что a ∘ e = e ∘ a = a для всех a

### 4. Обратный элемент
Для каждого a существует a⁻¹ такой, что a ∘ a⁻¹ = e

<GroupStructureDiagram client:load />

## Примеры групп

### Целые числа по сложению (ℤ, +)
- Операция: сложение
- Нейтральный элемент: 0
- Обратный для a: -a

### Ненулевые вещественные по умножению (ℝ*, ×)
- Операция: умножение
- Нейтральный элемент: 1
- Обратный для a: 1/a

### Вычеты по модулю n (ℤₙ, +)
- Множество: `{0, 1, 2, ..., n-1}`
- Операция: сложение по модулю n
- Нейтральный: 0
- Обратный для a: n - a

```python
# Группа ℤ₇ по сложению
n = 7
elements = list(range(n))

def group_add(a, b, n):
    return (a + b) % n

def inverse_add(a, n):
    return (n - a) % n

# Проверяем: a + inverse(a) = 0
for a in elements:
    inv = inverse_add(a, n)
    print(f"{a} + {inv} = {group_add(a, inv, n)}")  # Всегда 0
```

## Циклические группы

Группа называется **циклической**, если существует элемент g (генератор), такой что каждый элемент группы можно представить как g^k.

```python
# Мультипликативная группа ℤ₇*
# Элементы: {1, 2, 3, 4, 5, 6}
# Генератор: 3

g = 3
p = 7

print("Степени генератора 3:")
for k in range(1, p):
    print(f"3^{k} mod 7 = {pow(g, k, p)}")

# Вывод: 3, 2, 6, 4, 5, 1 — все элементы группы!
```

## Конечное поле (поле Галуа)

**Поле** — это множество с двумя операциями (сложением и умножением), где:
- (F, +) — абелева группа с нейтральным 0
- (F*, ×) — абелева группа с нейтральным 1 (исключая 0)
- Дистрибутивность: a × (b + c) = a × b + a × c

**Конечное поле GF(p)** (p — простое) — это множество `{0, 1, ..., p-1}` с операциями по модулю p.

<FieldOperationsDiagram client:load />

## Почему p должно быть простым?

Если p простое, то для каждого ненулевого a существует обратный элемент a⁻¹.

```python
def field_inverse(a: int, p: int) -> int:
    """Мультипликативный обратный в GF(p)"""
    # По малой теореме Ферма: a^(p-1) ≡ 1 (mod p)
    # Следовательно: a^(p-2) ≡ a^(-1) (mod p)
    return pow(a, p - 2, p)

p = 23
for a in [1, 5, 7, 11, 17]:
    inv = field_inverse(a, p)
    print(f"{a} * {inv} mod {p} = {(a * inv) % p}")  # Всегда 1
```

## Реализация конечного поля

```python
class GF:
    """Конечное поле GF(p)"""

    def __init__(self, value: int, p: int):
        self.value = value % p
        self.p = p

    def __add__(self, other):
        return GF((self.value + other.value) % self.p, self.p)

    def __sub__(self, other):
        return GF((self.value - other.value) % self.p, self.p)

    def __mul__(self, other):
        return GF((self.value * other.value) % self.p, self.p)

    def __truediv__(self, other):
        return self * other.inverse()

    def inverse(self):
        """Мультипликативный обратный"""
        return GF(pow(self.value, self.p - 2, self.p), self.p)

    def __pow__(self, exp):
        return GF(pow(self.value, exp, self.p), self.p)

    def __repr__(self):
        return f"GF({self.value})"

    def __eq__(self, other):
        return self.value == other.value and self.p == other.p

# Использование
p = 23
a = GF(7, p)
b = GF(13, p)

print(f"a + b = {a + b}")        # GF(20)
print(f"a * b = {a * b}")        # GF(91 % 23) = GF(0)
print(f"a / b = {a / b}")        # GF(7 * 13^(-1))
print(f"a^5 = {a ** 5}")         # GF(7^5 mod 23)
```

## Поля расширения GF(p^n)

Для криптографии на эллиптических кривых иногда используются **поля расширения** GF(p^n), где n > 1.

```python
# GF(2^8) используется в AES
# Элементы — полиномы степени < 8 с коэффициентами из {0, 1}
# Например: x^7 + x^3 + x + 1 = 10001011 = 139

# Умножение в GF(2^8) — это умножение полиномов по модулю
# неприводимого полинома (для AES: x^8 + x^4 + x^3 + x + 1)
```

## Порядок элемента

**Порядок элемента** a — это наименьшее положительное k, такое что a^k = 1.

```python
def element_order(a: int, p: int) -> int:
    """Найти порядок элемента в GF(p)*"""
    if a == 0:
        raise ValueError("0 не имеет порядка")

    order = 1
    current = a
    while current != 1:
        current = (current * a) % p
        order += 1
    return order

p = 23
for a in [2, 3, 5, 7]:
    print(f"ord({a}) = {element_order(a, p)}")

# Если ord(a) = p-1, то a — генератор (примитивный корень)
```

## Применение в криптографии

### RSA
- Работает в кольце ℤₙ, где n = p × q (произведение простых)
- Используется теорема Эйлера: a^φ(n) ≡ 1 (mod n)

### Эллиптические кривые
- Точки кривой образуют группу над GF(p)
- Операция — "сложение" точек (геометрическая операция)
- ECDSA использует эту групповую структуру

### Diffie-Hellman
- Работает в мультипликативной группе GF(p)*
- Безопасность основана на сложности дискретного логарифма

## Ключевые выводы

1. **Группа** — множество с одной операцией, удовлетворяющей 4 аксиомам
2. **Поле** — множество с двумя операциями (сложение и умножение)
3. **GF(p)** — конечное поле из p элементов (p — простое)
4. **Порядок элемента** — минимальная степень, дающая 1
5. **Генератор** — элемент с максимальным порядком

## Что дальше?

В следующем уроке мы изучим **хеш-функции** — односторонние функции, которые преобразуют данные любой длины в фиксированный "отпечаток". Вы узнаете, как работает SHA-256 изнутри.
