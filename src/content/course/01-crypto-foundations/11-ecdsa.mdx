---
title: "ECDSA — цифровые подписи"
description: "Алгоритм цифровой подписи на эллиптических кривых"
order: 11
difficulty: "advanced"
estimatedTime: 35
topics: ["ECDSA", "Digital Signatures", "Bitcoin", "Ethereum"]
---

import { ECDSASignDiagram, ECDSAVerifyDiagram, SignatureFormatDiagram } from '../../../components/diagrams/module1';

# ECDSA — цифровые подписи

## Что такое цифровая подпись?

**Цифровая подпись** доказывает:
1. **Аутентичность** — сообщение подписано владельцем приватного ключа
2. **Целостность** — сообщение не было изменено
3. **Неотрекаемость** — подписавший не может отрицать факт подписи

> **ECDSA** (Elliptic Curve Digital Signature Algorithm) — стандарт подписей в Bitcoin и Ethereum.

## Параметры ECDSA

Для ECDSA нужны:
- **Кривая** E над полем F_p
- **Генератор** G порядка n
- **Приватный ключ** d ∈ [1, n-1]
- **Публичный ключ** Q = d × G

## Алгоритм подписи

<ECDSASignDiagram client:load />

```python
import hashlib
import secrets
from typing import Tuple

class ECDSA:
    """ECDSA на secp256k1"""

    # Параметры secp256k1
    p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F
    n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141
    Gx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798
    Gy = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8

    @classmethod
    def sign(cls, message: bytes, private_key: int) -> Tuple[int, int]:
        """
        Создание ECDSA подписи:
        1. Вычислить z = hash(message) mod n
        2. Выбрать случайное k ∈ [1, n-1]
        3. Вычислить (x₁, y₁) = k × G
        4. r = x₁ mod n (если r = 0, выбрать новое k)
        5. s = k⁻¹ × (z + r × d) mod n (если s = 0, выбрать новое k)
        6. Подпись = (r, s)
        """
        # Шаг 1: Хеш сообщения
        z = int.from_bytes(hashlib.sha256(message).digest(), 'big') % cls.n

        while True:
            # Шаг 2: Случайное k
            k = secrets.randbelow(cls.n - 1) + 1

            # Шаг 3: k × G
            point = cls._multiply(k, (cls.Gx, cls.Gy))
            x1, y1 = point

            # Шаг 4: r = x₁ mod n
            r = x1 % cls.n
            if r == 0:
                continue

            # Шаг 5: s = k⁻¹ × (z + r × d) mod n
            k_inv = pow(k, -1, cls.n)
            s = (k_inv * (z + r * private_key)) % cls.n
            if s == 0:
                continue

            # Шаг 6: Нормализация s (low-s для Bitcoin)
            if s > cls.n // 2:
                s = cls.n - s

            return (r, s)

    @classmethod
    def verify(cls, message: bytes, signature: Tuple[int, int],
               public_key: Tuple[int, int]) -> bool:
        """
        Верификация ECDSA подписи:
        1. Проверить r, s ∈ [1, n-1]
        2. Вычислить z = hash(message) mod n
        3. Вычислить u₁ = z × s⁻¹ mod n
        4. Вычислить u₂ = r × s⁻¹ mod n
        5. Вычислить (x₁, y₁) = u₁ × G + u₂ × Q
        6. Подпись валидна если r ≡ x₁ (mod n)
        """
        r, s = signature

        # Шаг 1: Проверка диапазона
        if not (1 <= r < cls.n and 1 <= s < cls.n):
            return False

        # Шаг 2: Хеш сообщения
        z = int.from_bytes(hashlib.sha256(message).digest(), 'big') % cls.n

        # Шаг 3-4: Вычисление u₁ и u₂
        s_inv = pow(s, -1, cls.n)
        u1 = (z * s_inv) % cls.n
        u2 = (r * s_inv) % cls.n

        # Шаг 5: u₁ × G + u₂ × Q
        point1 = cls._multiply(u1, (cls.Gx, cls.Gy))
        point2 = cls._multiply(u2, public_key)
        result = cls._add(point1, point2)

        if result is None:  # Точка на бесконечности
            return False

        x1, y1 = result

        # Шаг 6: Проверка r ≡ x₁
        return r == x1 % cls.n

    @classmethod
    def _multiply(cls, k: int, P: Tuple[int, int]) -> Tuple[int, int]:
        """Скалярное умножение (double-and-add)"""
        result = None  # Точка на бесконечности
        addend = P

        while k:
            if k & 1:
                result = cls._add(result, addend)
            addend = cls._add(addend, addend)
            k >>= 1

        return result

    @classmethod
    def _add(cls, P, Q):
        """Сложение точек на secp256k1"""
        if P is None:
            return Q
        if Q is None:
            return P

        x1, y1 = P
        x2, y2 = Q

        if x1 == x2 and y1 == (-y2 % cls.p):
            return None  # Точка на бесконечности

        if P == Q:
            m = (3 * x1 * x1 * pow(2 * y1, -1, cls.p)) % cls.p
        else:
            m = ((y2 - y1) * pow(x2 - x1, -1, cls.p)) % cls.p

        x3 = (m * m - x1 - x2) % cls.p
        y3 = (m * (x1 - x3) - y1) % cls.p

        return (x3, y3)

# Тестирование
private_key = secrets.randbelow(ECDSA.n - 1) + 1
public_key = ECDSA._multiply(private_key, (ECDSA.Gx, ECDSA.Gy))

message = b"Hello, ECDSA!"
signature = ECDSA.sign(message, private_key)
print(f"Signature: r={hex(signature[0])[:20]}..., s={hex(signature[1])[:20]}...")

is_valid = ECDSA.verify(message, signature, public_key)
print(f"Valid: {is_valid}")

# Проверка с измененным сообщением
is_valid_fake = ECDSA.verify(b"Fake message", signature, public_key)
print(f"Fake valid: {is_valid_fake}")
```

## Формат подписи

<SignatureFormatDiagram client:load />

### DER формат (Bitcoin)

```python
def signature_to_der(r: int, s: int) -> bytes:
    """Кодирование подписи в DER формат"""
    def encode_integer(n: int) -> bytes:
        b = n.to_bytes((n.bit_length() + 8) // 8, 'big')
        # Добавляем 0x00 если старший бит установлен
        if b[0] & 0x80:
            b = b'\x00' + b
        return b'\x02' + bytes([len(b)]) + b

    r_encoded = encode_integer(r)
    s_encoded = encode_integer(s)

    content = r_encoded + s_encoded
    return b'\x30' + bytes([len(content)]) + content

def der_to_signature(der: bytes) -> Tuple[int, int]:
    """Декодирование DER подписи"""
    assert der[0] == 0x30
    length = der[1]
    assert der[2] == 0x02

    r_length = der[3]
    r = int.from_bytes(der[4:4+r_length], 'big')

    s_start = 4 + r_length
    assert der[s_start] == 0x02
    s_length = der[s_start + 1]
    s = int.from_bytes(der[s_start+2:s_start+2+s_length], 'big')

    return (r, s)

# Пример
r, s = signature
der_sig = signature_to_der(r, s)
print(f"DER signature: {der_sig.hex()}")
print(f"Length: {len(der_sig)} bytes")
```

### Compact формат (Ethereum)

```python
def signature_to_compact(r: int, s: int, v: int) -> bytes:
    """
    Ethereum использует 65-байтный формат: r (32) + s (32) + v (1)
    v = 27 или 28 (для legacy) или 0/1 (для EIP-155)
    """
    return r.to_bytes(32, 'big') + s.to_bytes(32, 'big') + bytes([v])

def compact_to_signature(compact: bytes) -> Tuple[int, int, int]:
    """Декодирование compact подписи"""
    r = int.from_bytes(compact[:32], 'big')
    s = int.from_bytes(compact[32:64], 'big')
    v = compact[64]
    return (r, s, v)
```

## Recovery ID и восстановление публичного ключа

В Ethereum подпись включает **recovery ID (v)**, позволяющий восстановить публичный ключ из подписи!

```python
def recover_public_key(message: bytes, signature: Tuple[int, int],
                        recovery_id: int) -> Tuple[int, int]:
    """
    Восстановление публичного ключа из подписи:
    1. Вычислить R = (r, y) где y определяется recovery_id
    2. z = hash(message) mod n
    3. Q = r⁻¹ × (s × R - z × G)
    """
    r, s = signature
    n = ECDSA.n
    p = ECDSA.p

    # Восстановить y из r и recovery_id
    x = r + (recovery_id >> 1) * n  # Учитываем возможное x > n

    # y² = x³ + 7 mod p
    y_squared = (pow(x, 3, p) + 7) % p
    y = pow(y_squared, (p + 1) // 4, p)

    # Выбираем правильную четность y
    if y % 2 != recovery_id % 2:
        y = p - y

    R = (x, y)

    # z = hash(message)
    z = int.from_bytes(hashlib.sha256(message).digest(), 'big') % n

    # Q = r⁻¹ × (s × R - z × G)
    r_inv = pow(r, -1, n)
    sR = ECDSA._multiply(s, R)
    zG = ECDSA._multiply(z, (ECDSA.Gx, ECDSA.Gy))
    neg_zG = (zG[0], (-zG[1]) % p)

    point = ECDSA._add(sR, neg_zG)
    Q = ECDSA._multiply(r_inv, point)

    return Q
```

## Использование в Bitcoin и Ethereum

### Bitcoin подпись транзакции

```python
from ecdsa import SECP256k1, SigningKey
import hashlib

def sign_bitcoin_message(message: bytes, private_key: bytes) -> bytes:
    """Подпись сообщения в стиле Bitcoin"""
    # Добавляем magic prefix
    prefix = b"\x18Bitcoin Signed Message:\n"
    message_len = len(message).to_bytes(1, 'big')
    full_message = prefix + message_len + message

    # Double SHA256
    msg_hash = hashlib.sha256(hashlib.sha256(full_message).digest()).digest()

    # Подпись
    sk = SigningKey.from_string(private_key, curve=SECP256k1)
    signature = sk.sign_digest(msg_hash, sigencode=lambda r, s, _: (r, s))

    return signature
```

### Ethereum подпись транзакции

```python
from eth_account import Account
from eth_account.messages import encode_defunct

def sign_ethereum_message(message: str, private_key: str) -> dict:
    """Подпись сообщения в стиле Ethereum"""
    # Encode message (EIP-191)
    encoded = encode_defunct(text=message)

    # Подпись
    signed = Account.sign_message(encoded, private_key)

    return {
        "messageHash": signed.messageHash.hex(),
        "r": hex(signed.r),
        "s": hex(signed.s),
        "v": signed.v,
        "signature": signed.signature.hex()
    }

def verify_ethereum_signature(message: str, signature: bytes) -> str:
    """Восстановить адрес подписавшего"""
    encoded = encode_defunct(text=message)
    return Account.recover_message(encoded, signature=signature)

# Пример
private_key = "0x" + secrets.token_hex(32)
account = Account.from_key(private_key)

message = "I authorize this transaction"
signed = sign_ethereum_message(message, private_key)

print(f"Address: {account.address}")
print(f"Signature: {signed['signature'][:42]}...")

recovered = verify_ethereum_signature(message, bytes.fromhex(signed['signature'][2:]))
print(f"Recovered: {recovered}")
print(f"Match: {recovered.lower() == account.address.lower()}")
```

## Уязвимости ECDSA

### 1. Повторное использование k (КРИТИЧНО!)

```python
# Если одно и то же k используется дважды, приватный ключ раскрывается!

# Подпись 1: s₁ = k⁻¹(z₁ + r·d)
# Подпись 2: s₂ = k⁻¹(z₂ + r·d)

# s₁ - s₂ = k⁻¹(z₁ - z₂)
# k = (z₁ - z₂) / (s₁ - s₂)

# Зная k:
# d = (s·k - z) / r

def crack_private_key_from_reused_k(z1, z2, r, s1, s2, n):
    """Восстановить приватный ключ при повторном k"""
    # k = (z1 - z2) * (s1 - s2)^(-1) mod n
    k = ((z1 - z2) * pow(s1 - s2, -1, n)) % n

    # d = (s1 * k - z1) * r^(-1) mod n
    d = ((s1 * k - z1) * pow(r, -1, n)) % n

    return d

# Это реальная атака! PlayStation 3 была взломана из-за повторного k!
```

### 2. Biased k

```python
# Если k имеет статистическое смещение (например, несколько старших бит = 0)
# Можно применить lattice-атаку для восстановления приватного ключа
# Решение: использовать RFC 6979 для детерминированного k
```

### 3. Low-s malleability

```python
# Подпись (r, s) эквивалентна (r, n - s)
# Bitcoin требует s < n/2 для предотвращения malleability

def normalize_s(s: int, n: int) -> int:
    """Нормализация s для предотвращения malleability"""
    if s > n // 2:
        return n - s
    return s
```

## RFC 6979: Детерминированный k

```python
import hmac
import hashlib

def rfc6979_k(message_hash: bytes, private_key: int, n: int) -> int:
    """
    Детерминированная генерация k по RFC 6979
    Устраняет риск повторного k
    """
    x = private_key.to_bytes(32, 'big')
    h1 = message_hash

    # Инициализация
    v = b'\x01' * 32
    k = b'\x00' * 32

    # Итерации
    k = hmac.new(k, v + b'\x00' + x + h1, hashlib.sha256).digest()
    v = hmac.new(k, v, hashlib.sha256).digest()
    k = hmac.new(k, v + b'\x01' + x + h1, hashlib.sha256).digest()
    v = hmac.new(k, v, hashlib.sha256).digest()

    # Генерация k
    while True:
        v = hmac.new(k, v, hashlib.sha256).digest()
        candidate = int.from_bytes(v, 'big')
        if 1 <= candidate < n:
            return candidate
        k = hmac.new(k, v + b'\x00', hashlib.sha256).digest()
        v = hmac.new(k, v, hashlib.sha256).digest()
```

## Ключевые выводы

1. **ECDSA** — стандарт подписей в Bitcoin/Ethereum
2. **Подпись (r, s)** создается с использованием случайного k
3. **k должен быть уникальным** — повторное использование раскрывает приватный ключ
4. **Recovery ID (v)** позволяет восстановить публичный ключ из подписи
5. **RFC 6979** — безопасная детерминированная генерация k

## Что дальше?

В следующем уроке мы изучим **EdDSA и Schnorr подписи** — более современные алгоритмы с детерминированными подписями.
