---
title: "Симметричное шифрование и AES"
description: "Алгоритм AES — стандарт симметричного шифрования"
order: 6
difficulty: "intermediate"
estimatedTime: 30
topics: ["AES", "Symmetric Encryption", "Block Ciphers"]
---

import { AESStructureDiagram, AESRoundDiagram, SubBytesDiagram, MixColumnsDiagram } from '../../../components/diagrams/module1';

# Симметричное шифрование и AES

## Симметричное vs Асимметричное шифрование

| Характеристика | Симметричное | Асимметричное |
|----------------|--------------|---------------|
| Ключи | Один общий | Пара: публичный + приватный |
| Скорость | Быстро | Медленно |
| Применение | Шифрование данных | Обмен ключами, подписи |
| Примеры | AES, ChaCha20 | RSA, ECDSA |

> **На практике** используют гибридный подход: асимметричная криптография для обмена ключом, симметричная — для шифрования данных.

## AES — Advanced Encryption Standard

**AES** (Rijndael) — блочный шифр, принятый как стандарт в 2001 году.

<AESStructureDiagram client:load />

### Параметры AES

| Вариант | Размер ключа | Раунды |
|---------|--------------|--------|
| AES-128 | 128 бит | 10 |
| AES-192 | 192 бит | 12 |
| AES-256 | 256 бит | 14 |

Размер блока всегда **128 бит (16 байт)**.

## Состояние AES

Состояние AES — матрица 4×4 байта:

```python
def bytes_to_state(data: bytes) -> list:
    """Преобразовать 16 байт в матрицу 4x4"""
    # Заполняется по столбцам!
    state = [[0] * 4 for _ in range(4)]
    for i in range(16):
        state[i % 4][i // 4] = data[i]
    return state

def state_to_bytes(state: list) -> bytes:
    """Преобразовать матрицу обратно в байты"""
    result = []
    for col in range(4):
        for row in range(4):
            result.append(state[row][col])
    return bytes(result)

# Пример
plaintext = b"0123456789abcdef"
state = bytes_to_state(plaintext)
print("State matrix:")
for row in state:
    print([hex(b) for b in row])
```

## Четыре операции раунда

Каждый раунд AES состоит из 4 операций:

<AESRoundDiagram client:load />

### 1. SubBytes — Замена байтов

Каждый байт заменяется через таблицу подстановки (S-box).

<SubBytesDiagram client:load />

```python
# S-box AES — результат композиции инверсии в GF(2^8) и аффинного преобразования
S_BOX = [
    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16,
]

def sub_bytes(state):
    """Замена каждого байта через S-box"""
    for i in range(4):
        for j in range(4):
            state[i][j] = S_BOX[state[i][j]]
    return state
```

### 2. ShiftRows — Сдвиг строк

Строки сдвигаются циклически влево:
- Строка 0: без сдвига
- Строка 1: сдвиг на 1
- Строка 2: сдвиг на 2
- Строка 3: сдвиг на 3

```python
def shift_rows(state):
    """Циклический сдвиг строк"""
    state[1] = state[1][1:] + state[1][:1]
    state[2] = state[2][2:] + state[2][:2]
    state[3] = state[3][3:] + state[3][:3]
    return state
```

### 3. MixColumns — Смешивание столбцов

Каждый столбец умножается на фиксированную матрицу в GF(2⁸).

<MixColumnsDiagram client:load />

```python
def gf_multiply(a, b):
    """Умножение в GF(2^8) с неприводимым полиномом x^8 + x^4 + x^3 + x + 1"""
    result = 0
    for _ in range(8):
        if b & 1:
            result ^= a
        hi_bit = a & 0x80
        a = (a << 1) & 0xFF
        if hi_bit:
            a ^= 0x1B  # x^8 + x^4 + x^3 + x + 1
        b >>= 1
    return result

def mix_columns(state):
    """Смешивание столбцов через умножение в GF(2^8)"""
    # Матрица смешивания
    matrix = [
        [0x02, 0x03, 0x01, 0x01],
        [0x01, 0x02, 0x03, 0x01],
        [0x01, 0x01, 0x02, 0x03],
        [0x03, 0x01, 0x01, 0x02]
    ]

    for col in range(4):
        column = [state[row][col] for row in range(4)]
        new_column = []
        for row in range(4):
            val = 0
            for i in range(4):
                val ^= gf_multiply(matrix[row][i], column[i])
            new_column.append(val)
        for row in range(4):
            state[row][col] = new_column[row]

    return state
```

### 4. AddRoundKey — Добавление ключа раунда

XOR состояния с ключом раунда.

```python
def add_round_key(state, round_key):
    """XOR состояния с ключом раунда"""
    for i in range(4):
        for j in range(4):
            state[i][j] ^= round_key[i][j]
    return state
```

## Key Schedule — Расширение ключа

Из исходного ключа генерируются ключи для каждого раунда.

```python
# Константы для расширения ключа
RCON = [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36]

def key_expansion(key: bytes) -> list:
    """Расширение 128-битного ключа в 11 раундовых ключей"""
    # Преобразуем ключ в words (4 байта каждый)
    words = []
    for i in range(4):
        words.append(list(key[i*4:(i+1)*4]))

    for i in range(4, 44):  # 44 слова для AES-128
        temp = words[i-1].copy()

        if i % 4 == 0:
            # RotWord
            temp = temp[1:] + temp[:1]
            # SubWord
            temp = [S_BOX[b] for b in temp]
            # XOR с Rcon
            temp[0] ^= RCON[i // 4 - 1]

        words.append([a ^ b for a, b in zip(words[i-4], temp)])

    # Преобразуем слова в раундовые ключи (матрицы 4x4)
    round_keys = []
    for r in range(11):
        key_matrix = [[0] * 4 for _ in range(4)]
        for col in range(4):
            for row in range(4):
                key_matrix[row][col] = words[r*4 + col][row]
        round_keys.append(key_matrix)

    return round_keys
```

## Полная реализация AES-128

```python
class AES128:
    """Реализация AES-128 шифрования"""

    def __init__(self, key: bytes):
        if len(key) != 16:
            raise ValueError("Key must be 16 bytes")
        self.round_keys = key_expansion(key)

    def encrypt_block(self, plaintext: bytes) -> bytes:
        """Зашифровать один 16-байтный блок"""
        if len(plaintext) != 16:
            raise ValueError("Block must be 16 bytes")

        state = bytes_to_state(plaintext)

        # Начальный раунд
        state = add_round_key(state, self.round_keys[0])

        # Раунды 1-9
        for round_num in range(1, 10):
            state = sub_bytes(state)
            state = shift_rows(state)
            state = mix_columns(state)
            state = add_round_key(state, self.round_keys[round_num])

        # Финальный раунд (без MixColumns)
        state = sub_bytes(state)
        state = shift_rows(state)
        state = add_round_key(state, self.round_keys[10])

        return state_to_bytes(state)

    def decrypt_block(self, ciphertext: bytes) -> bytes:
        """Расшифровать один 16-байтный блок"""
        # Обратные операции в обратном порядке
        # (опущено для краткости — см. полную реализацию в лабораторных)
        pass

# Тестирование
from Crypto.Cipher import AES as CryptoAES

key = b"0123456789abcdef"
plaintext = b"Hello, AES-128!!"

# Наша реализация
aes = AES128(key)
our_ciphertext = aes.encrypt_block(plaintext)

# Библиотечная реализация (ECB mode)
cipher = CryptoAES.new(key, CryptoAES.MODE_ECB)
lib_ciphertext = cipher.encrypt(plaintext)

print(f"Plaintext:  {plaintext}")
print(f"Our cipher: {our_ciphertext.hex()}")
print(f"Lib cipher: {lib_ciphertext.hex()}")
print(f"Match: {our_ciphertext == lib_ciphertext}")
```

## Использование в криптовалютах

### 1. Шифрование кошельков

```python
from Crypto.Cipher import AES
from Crypto.Protocol.KDF import scrypt
from Crypto.Random import get_random_bytes

def encrypt_private_key(private_key: bytes, password: str) -> dict:
    """Зашифровать приватный ключ паролем (как в Ethereum keystore)"""
    salt = get_random_bytes(32)

    # Derive key from password
    derived_key = scrypt(
        password.encode(),
        salt=salt,
        key_len=32,
        N=2**18,  # CPU/memory cost
        r=8,
        p=1
    )

    encryption_key = derived_key[:16]
    mac_key = derived_key[16:]

    # Encrypt
    iv = get_random_bytes(16)
    cipher = AES.new(encryption_key, AES.MODE_CTR, nonce=iv[:8])
    ciphertext = cipher.encrypt(private_key)

    # MAC for integrity
    from Crypto.Hash import keccak
    mac = keccak.new(digest_bits=256)
    mac.update(mac_key + ciphertext)

    return {
        "cipher": "aes-128-ctr",
        "ciphertext": ciphertext.hex(),
        "iv": iv.hex(),
        "salt": salt.hex(),
        "mac": mac.hexdigest()
    }
```

### 2. Шифрование в протоколах

```python
# Многие протоколы используют AES-GCM для аутентифицированного шифрования
from Crypto.Cipher import AES

def aes_gcm_encrypt(key: bytes, plaintext: bytes, aad: bytes = b"") -> tuple:
    """AES-GCM шифрование с аутентификацией"""
    cipher = AES.new(key, AES.MODE_GCM)
    cipher.update(aad)  # Associated data (не шифруется, но аутентифицируется)
    ciphertext, tag = cipher.encrypt_and_digest(plaintext)
    return cipher.nonce, ciphertext, tag

def aes_gcm_decrypt(key: bytes, nonce: bytes, ciphertext: bytes,
                     tag: bytes, aad: bytes = b"") -> bytes:
    """AES-GCM расшифрование с проверкой"""
    cipher = AES.new(key, AES.MODE_GCM, nonce=nonce)
    cipher.update(aad)
    return cipher.decrypt_and_verify(ciphertext, tag)
```

## Ключевые выводы

1. **AES** — блочный шифр с блоком 128 бит и ключами 128/192/256 бит
2. **Состояние** — матрица 4×4 байта
3. **4 операции раунда**: SubBytes, ShiftRows, MixColumns, AddRoundKey
4. **S-box** обеспечивает нелинейность (стойкость к линейному криптоанализу)
5. **MixColumns** обеспечивает диффузию (каждый бит влияет на все выходные)

## Что дальше?

В следующем уроке мы изучим **режимы работы блочных шифров** — CBC, CTR, GCM и почему никогда нельзя использовать ECB.
