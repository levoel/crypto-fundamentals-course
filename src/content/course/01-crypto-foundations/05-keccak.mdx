---
title: "Keccak и SHA-3"
description: "Хеш-функция Ethereum — алгоритм Keccak (SHA-3)"
order: 5
difficulty: "intermediate"
estimatedTime: 30
topics: ["Keccak", "SHA-3", "Sponge Construction", "Ethereum"]
---

import { KeccakSpongeDiagram, KeccakStateDiagram, KeccakRoundDiagram } from '../../../components/diagrams/module1';

# Keccak и SHA-3

## Почему другая хеш-функция?

После того как были найдены уязвимости в MD5 и SHA-1, NIST объявил конкурс на новый стандарт хеширования. В 2012 году победил **Keccak** и стал **SHA-3**.

> **Важно:** Ethereum использует **Keccak-256**, который немного отличается от финального стандарта SHA-3-256!

## Принципиальное отличие от SHA-2

| Характеристика | SHA-256 | Keccak |
|----------------|---------|--------|
| Конструкция | Merkle-Damgård | **Sponge** |
| Размер состояния | 256 бит | **1600 бит** |
| Блок данных | 512 бит | 1088 бит (для Keccak-256) |
| Раундовая функция | Сжатие | Перестановка |

## Sponge Construction (Губчатая конструкция)

Keccak использует **губчатую конструкцию** с двумя фазами: absorbing (впитывание) и squeezing (выжимание).

<KeccakSpongeDiagram client:load />

```python
def sponge_concept(message, rate, output_len):
    """
    Концептуальная модель губчатой конструкции:

    state = 0

    # Фаза впитывания (Absorbing)
    for block in split(message, rate):
        state = state XOR block
        state = permutation(state)

    # Фаза выжимания (Squeezing)
    output = ""
    while len(output) < output_len:
        output += state[:rate]
        state = permutation(state)

    return output[:output_len]
    """
    pass
```

### Параметры Sponge

- **r (rate)** — сколько бит обрабатывается за раз
- **c (capacity)** — скрытая часть состояния (безопасность)
- **b = r + c** — общий размер состояния (1600 для Keccak)

Для Keccak-256: r = 1088, c = 512

## Состояние Keccak

Состояние Keccak — это 3D массив 5×5×64 бит = 1600 бит.

<KeccakStateDiagram client:load />

```python
import numpy as np

def initialize_state():
    """Создать начальное состояние 5x5x64"""
    return np.zeros((5, 5, 64), dtype=np.uint8)

def state_to_bytes(state):
    """Преобразовать состояние в байты"""
    result = bytearray(200)  # 1600 / 8 = 200 байт
    for x in range(5):
        for y in range(5):
            for z in range(64):
                bit_index = 64 * (5 * y + x) + z
                byte_index = bit_index // 8
                bit_offset = bit_index % 8
                result[byte_index] |= state[x, y, z] << bit_offset
    return bytes(result)
```

## Пять операций раунда

Каждый раунд Keccak состоит из пяти операций: θ (theta), ρ (rho), π (pi), χ (chi), ι (iota).

<KeccakRoundDiagram client:load />

### θ (Theta) — Смешивание столбцов

```python
def theta(state):
    """
    θ: XOR каждого бита с четностью двух столбцов
    C[x] = A[x,0] ⊕ A[x,1] ⊕ A[x,2] ⊕ A[x,3] ⊕ A[x,4]
    D[x] = C[x-1] ⊕ ROT(C[x+1], 1)
    A'[x,y] = A[x,y] ⊕ D[x]
    """
    C = [[0] * 64 for _ in range(5)]

    # Вычисляем четность столбцов
    for x in range(5):
        for z in range(64):
            C[x][z] = state[x][0][z] ^ state[x][1][z] ^ state[x][2][z] ^ \
                      state[x][3][z] ^ state[x][4][z]

    # Вычисляем D и применяем
    for x in range(5):
        for y in range(5):
            for z in range(64):
                state[x][y][z] ^= C[(x-1) % 5][z] ^ C[(x+1) % 5][(z-1) % 64]

    return state
```

### ρ (Rho) — Вращение внутри lane

```python
# Таблица смещений для ρ
RHO_OFFSETS = [
    [0, 36, 3, 41, 18],
    [1, 44, 10, 45, 2],
    [62, 6, 43, 15, 61],
    [28, 55, 25, 21, 56],
    [27, 20, 39, 8, 14]
]

def rho(state):
    """
    ρ: Циклический сдвиг каждого lane на фиксированную величину
    A'[x,y,z] = A[x,y,(z - offset[x,y]) mod 64]
    """
    for x in range(5):
        for y in range(5):
            offset = RHO_OFFSETS[x][y]
            lane = state[x][y]
            state[x][y] = [lane[(z - offset) % 64] for z in range(64)]
    return state
```

### π (Pi) — Перестановка lanes

```python
def pi(state):
    """
    π: Переставляет lanes по правилу
    A'[y, 2x+3y mod 5] = A[x,y]
    """
    new_state = [[[0] * 64 for _ in range(5)] for _ in range(5)]
    for x in range(5):
        for y in range(5):
            new_state[y][(2*x + 3*y) % 5] = state[x][y]
    return new_state
```

### χ (Chi) — Нелинейное преобразование

```python
def chi(state):
    """
    χ: Единственное нелинейное преобразование
    A'[x,y] = A[x,y] ⊕ ((¬A[x+1,y]) ∧ A[x+2,y])
    """
    new_state = [[[0] * 64 for _ in range(5)] for _ in range(5)]
    for x in range(5):
        for y in range(5):
            for z in range(64):
                new_state[x][y][z] = state[x][y][z] ^ \
                    ((1 ^ state[(x+1) % 5][y][z]) & state[(x+2) % 5][y][z])
    return new_state
```

### ι (Iota) — Добавление константы раунда

```python
# Константы раундов (для 64-битных lanes, 24 раунда)
RC = [
    0x0000000000000001, 0x0000000000008082, 0x800000000000808A,
    0x8000000080008000, 0x000000000000808B, 0x0000000080000001,
    0x8000000080008081, 0x8000000000008009, 0x000000000000008A,
    0x0000000000000088, 0x0000000080008009, 0x000000008000000A,
    0x000000008000808B, 0x800000000000008B, 0x8000000000008089,
    0x8000000000008003, 0x8000000000008002, 0x8000000000000080,
    0x000000000000800A, 0x800000008000000A, 0x8000000080008081,
    0x8000000000008080, 0x0000000080000001, 0x8000000080008008
]

def iota(state, round_num):
    """
    ι: XOR константы раунда с A[0,0]
    A'[0,0,z] = A[0,0,z] ⊕ RC[round][z]
    """
    rc = RC[round_num]
    for z in range(64):
        state[0][0][z] ^= (rc >> z) & 1
    return state
```

## Полный раунд Keccak-f

```python
def keccak_f(state):
    """24 раунда перестановки Keccak-f[1600]"""
    for round_num in range(24):
        state = theta(state)
        state = rho(state)
        state = pi(state)
        state = chi(state)
        state = iota(state, round_num)
    return state
```

## Keccak-256 vs SHA-3-256

**Важное различие для Ethereum:**

```python
from Crypto.Hash import keccak, SHA3_256

message = b"hello"

# Ethereum использует Keccak-256 (до финализации NIST)
keccak_hash = keccak.new(digest_bits=256)
keccak_hash.update(message)
print(f"Keccak-256: {keccak_hash.hexdigest()}")
# 1c8aff950685c2ed4bc3174f3472287b56d9517b9c948127319a09a7a36deac8

# SHA-3-256 (стандарт NIST) имеет другой padding
sha3_hash = SHA3_256.new()
sha3_hash.update(message)
print(f"SHA-3-256:  {sha3_hash.hexdigest()}")
# 3338be694f50c5f338814986cdf0686453a888b84f424d792af4b9202398f392
```

Разница в **padding byte**: Keccak использует `0x01`, SHA-3 использует `0x06`.

## Использование в Ethereum

```python
from eth_hash.auto import keccak

# Адрес из публичного ключа
def eth_address_from_pubkey(pubkey_bytes):
    """
    Ethereum address = последние 20 байт Keccak256(pubkey)
    """
    full_hash = keccak(pubkey_bytes)
    return '0x' + full_hash[-20:].hex()

# Селектор функции
def function_selector(signature):
    """
    Selector = первые 4 байта Keccak256(signature)
    """
    return keccak(signature.encode())[:4].hex()

print(function_selector("transfer(address,uint256)"))
# a9059cbb — селектор функции transfer в ERC-20
```

## Практическая реализация

```python
from Crypto.Hash import keccak

class Keccak256:
    """Обертка для удобного использования Keccak-256"""

    @staticmethod
    def hash(data: bytes) -> bytes:
        k = keccak.new(digest_bits=256)
        k.update(data)
        return k.digest()

    @staticmethod
    def hash_hex(data: bytes) -> str:
        return Keccak256.hash(data).hex()

# Примеры из Ethereum
examples = [
    b"",
    b"hello",
    bytes.fromhex("deadbeef"),
]

for data in examples:
    print(f"Keccak256({data.hex() or 'empty'}) = {Keccak256.hash_hex(data)}")
```

## Применение в блокчейне

### 1. Адреса Ethereum

```python
# Публичный ключ (без префикса 04)
pubkey = bytes.fromhex(
    "50863ad64a87ae8a2fe83c1af1a8403cb53f53e486d8511dad8a04887e5b2352"
    "2cd470243453a299fa9e77237716103abc11a1df38855ed6f2ee187e9c582ba6"
)

# Keccak-256 хеш
pubkey_hash = keccak.new(digest_bits=256, data=pubkey).digest()

# Последние 20 байт = адрес
address = "0x" + pubkey_hash[-20:].hex()
print(f"Address: {address}")
# 0x001d3f1ef827552ae1114027bd3ecf1f086ba0f9
```

### 2. Хеши транзакций

```python
# Закодированная транзакция
tx_rlp = bytes.fromhex("f86c...")  # RLP-encoded transaction

# Хеш транзакции
tx_hash = keccak.new(digest_bits=256, data=tx_rlp).hexdigest()
print(f"Transaction hash: 0x{tx_hash}")
```

### 3. Storage slots в смарт-контрактах

```python
def get_mapping_slot(mapping_slot: int, key: bytes) -> bytes:
    """
    Вычислить slot для mapping[key]
    slot = keccak256(key . mapping_slot)
    """
    k = keccak.new(digest_bits=256)
    k.update(key.rjust(32, b'\x00'))
    k.update(mapping_slot.to_bytes(32, 'big'))
    return k.digest()
```

## Ключевые выводы

1. **Keccak** использует губчатую конструкцию вместо Merkle-Damgård
2. **Состояние** — 1600 бит (5×5×64), намного больше чем у SHA-256
3. **24 раунда** из 5 операций: θ, ρ, π, χ, ι
4. **χ** — единственная нелинейная операция
5. **Ethereum использует Keccak-256**, не SHA-3-256!

## Что дальше?

В следующем уроке мы перейдем к **симметричному шифрованию** и изучим AES — алгоритм, защищающий большую часть интернет-трафика.
