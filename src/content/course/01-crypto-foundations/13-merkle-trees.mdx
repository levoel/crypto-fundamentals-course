---
title: "Деревья Меркла"
description: "Структура данных для эффективной верификации в блокчейне"
order: 13
difficulty: "intermediate"
estimatedTime: 25
topics: ["Merkle Trees", "Data Structures", "Bitcoin", "Ethereum"]
---

import { MerkleTreeDiagram, MerkleConstructionDiagram, MerkleProofDiagram } from '../../../components/diagrams/module1';

# Деревья Меркла

## Что такое дерево Меркла?

**Дерево Меркла** (Merkle Tree) — это бинарное дерево хешей, где:
- **Листья** — хеши данных (транзакций)
- **Внутренние узлы** — хеши конкатенации дочерних узлов
- **Корень** — единственный хеш, представляющий все данные

<MerkleTreeDiagram client:load />

> **Изобретено** Ральфом Мерклом в 1979 году. Используется в Git, BitTorrent, и всех современных блокчейнах.

## Зачем нужны деревья Меркла?

1. **Компактное представление** — весь набор данных представлен одним хешем
2. **Эффективная верификация** — проверка включения за O(log n)
3. **Выявление различий** — быстрое нахождение измененных данных
4. **Легкие клиенты** — верификация без скачивания всех данных

## Построение дерева Меркла

<MerkleConstructionDiagram client:load />

```python
import hashlib
from typing import List, Optional

def hash256(data: bytes) -> bytes:
    """Double SHA256 (как в Bitcoin)"""
    return hashlib.sha256(hashlib.sha256(data).digest()).digest()

def build_merkle_tree(leaves: List[bytes]) -> List[List[bytes]]:
    """
    Построить дерево Меркла:
    1. Если нечетное количество листьев — дублируем последний
    2. Хешируем пары соседних узлов
    3. Повторяем пока не останется один узел (корень)
    """
    if not leaves:
        return [[hash256(b'')]]

    # Уровень 0: листья (хеши данных)
    tree = [leaves[:]]

    current_level = leaves[:]

    while len(current_level) > 1:
        # Дублируем последний если нечетное количество
        if len(current_level) % 2 == 1:
            current_level.append(current_level[-1])

        # Вычисляем следующий уровень
        next_level = []
        for i in range(0, len(current_level), 2):
            combined = current_level[i] + current_level[i + 1]
            next_level.append(hash256(combined))

        tree.append(next_level)
        current_level = next_level

    return tree

def get_merkle_root(leaves: List[bytes]) -> bytes:
    """Получить корень дерева Меркла"""
    tree = build_merkle_tree(leaves)
    return tree[-1][0]

# Пример: транзакции как в Bitcoin
transactions = [
    b"tx1: Alice -> Bob: 1 BTC",
    b"tx2: Bob -> Charlie: 0.5 BTC",
    b"tx3: Charlie -> Dave: 0.3 BTC",
    b"tx4: Dave -> Eve: 0.1 BTC",
]

# Хешируем транзакции
tx_hashes = [hash256(tx) for tx in transactions]

# Строим дерево
tree = build_merkle_tree(tx_hashes)
root = tree[-1][0]

print(f"Transactions: {len(transactions)}")
print(f"Tree levels: {len(tree)}")
print(f"Merkle root: {root.hex()}")
```

## Структура дерева

```python
def visualize_merkle_tree(tree: List[List[bytes]]):
    """Визуализация дерева Меркла"""
    for level, nodes in enumerate(tree):
        level_name = "Leaves" if level == 0 else f"Level {level}" if level < len(tree) - 1 else "Root"
        print(f"\n{level_name}:")
        for i, node in enumerate(nodes):
            print(f"  [{i}] {node.hex()[:16]}...")

visualize_merkle_tree(tree)

# Вывод:
# Leaves:
#   [0] 5d41402abc4b2a76...
#   [1] 7d793037a0760186...
#   [2] 6b23c0d5f35d1b11...
#   [3] 9f86d081884c7d65...

# Level 1:
#   [0] 3f79bb7b435b0533...
#   [1] 8c7dd922ad47494f...

# Root:
#   [0] 2c26b46b68ffc68f...
```

## Класс MerkleTree

```python
class MerkleTree:
    """Полная реализация дерева Меркла"""

    def __init__(self, data: List[bytes], hash_func=hash256):
        self.hash_func = hash_func
        self.leaves = [hash_func(d) for d in data]
        self.tree = self._build_tree(self.leaves)

    def _build_tree(self, leaves: List[bytes]) -> List[List[bytes]]:
        """Построить дерево из листьев"""
        if not leaves:
            return [[self.hash_func(b'')]]

        tree = [leaves[:]]
        current = leaves[:]

        while len(current) > 1:
            if len(current) % 2 == 1:
                current.append(current[-1])

            next_level = []
            for i in range(0, len(current), 2):
                combined = current[i] + current[i + 1]
                next_level.append(self.hash_func(combined))

            tree.append(next_level)
            current = next_level

        return tree

    @property
    def root(self) -> bytes:
        """Корень дерева"""
        return self.tree[-1][0]

    def get_proof(self, index: int) -> List[tuple]:
        """
        Получить proof для элемента по индексу.
        Возвращает список (hash, position) где position = 'left' или 'right'
        """
        if index < 0 or index >= len(self.leaves):
            raise IndexError("Index out of range")

        proof = []
        current_index = index

        for level in self.tree[:-1]:  # Все уровни кроме корня
            # Определяем сестринский узел
            if current_index % 2 == 0:
                # Текущий слева, сестринский справа
                sibling_index = current_index + 1
                position = 'right'
            else:
                # Текущий справа, сестринский слева
                sibling_index = current_index - 1
                position = 'left'

            # Добавляем сестринский узел в proof
            if sibling_index < len(level):
                proof.append((level[sibling_index], position))
            else:
                # Если нет сестринского, используем сам узел (дублирование)
                proof.append((level[current_index], position))

            current_index //= 2

        return proof

    def verify_proof(self, leaf_hash: bytes, proof: List[tuple]) -> bool:
        """Проверить proof"""
        current = leaf_hash

        for sibling_hash, position in proof:
            if position == 'left':
                current = self.hash_func(sibling_hash + current)
            else:
                current = self.hash_func(current + sibling_hash)

        return current == self.root

# Использование
data = [b"A", b"B", b"C", b"D", b"E"]
tree = MerkleTree(data)

print(f"Root: {tree.root.hex()}")

# Получаем proof для элемента "C" (индекс 2)
proof = tree.get_proof(2)
print(f"\nProof for 'C':")
for h, pos in proof:
    print(f"  {pos}: {h.hex()[:16]}...")

# Верификация
leaf_hash = hash256(b"C")
is_valid = tree.verify_proof(leaf_hash, proof)
print(f"\nProof valid: {is_valid}")
```

## Merkle Root в Bitcoin

```python
def bitcoin_merkle_root(tx_hashes: List[bytes]) -> bytes:
    """
    Вычисление Merkle Root как в Bitcoin:
    - Хеши в little-endian
    - Используется double SHA256
    - При нечетном количестве дублируется последний
    """
    if len(tx_hashes) == 0:
        return hash256(b'')

    if len(tx_hashes) == 1:
        return tx_hashes[0]

    # Обработка списка
    current = tx_hashes[:]

    while len(current) > 1:
        if len(current) % 2 == 1:
            current.append(current[-1])

        next_level = []
        for i in range(0, len(current), 2):
            # Bitcoin использует конкатенацию в natural order
            combined = current[i] + current[i + 1]
            next_level.append(hash256(combined))

        current = next_level

    return current[0]

# Пример из реального блока Bitcoin
# Block 170: первый блок с транзакцией (кроме coinbase)
tx_hashes_hex = [
    "b1fea52486ce0c62bb442b530a3f0132b826c74e473d1f2c220bfa78111c5082",
    "f4184fc596403b9d638783cf57adfe4c75c605f6356fbc91338530e9831e9e16"
]

tx_hashes = [bytes.fromhex(h)[::-1] for h in tx_hashes_hex]  # Little-endian
merkle_root = bitcoin_merkle_root(tx_hashes)
print(f"Merkle root: {merkle_root[::-1].hex()}")  # Back to big-endian for display
```

## Merkle Patricia Trie в Ethereum

Ethereum использует более сложную структуру — **Merkle Patricia Trie**:

```python
# Ethereum хранит три типа данных в MPT:
# 1. State Trie: account_address -> account_state
# 2. Storage Trie: storage_key -> storage_value
# 3. Transaction Trie: tx_index -> tx_data
# 4. Receipt Trie: tx_index -> receipt

# Структура MPT:
# - Extension Node: общий префикс
# - Branch Node: 16 + 1 детей (hex digits + value)
# - Leaf Node: остаток пути + значение

# Пример структуры аккаунта:
account_state = {
    "nonce": 0,
    "balance": 1000000000000000000,  # 1 ETH in wei
    "storage_root": bytes(32),  # Hash of storage trie
    "code_hash": bytes(32),  # Hash of contract code
}
```

## Применение в блокчейне

### 1. Верификация транзакции (SPV)

```python
def verify_transaction_inclusion(
    tx_hash: bytes,
    merkle_proof: List[tuple],
    merkle_root: bytes,
    block_header: bytes
) -> bool:
    """
    Легкий клиент может проверить транзакцию:
    1. Получить merkle proof от полного узла
    2. Вычислить merkle root из proof
    3. Сравнить с merkle root в заголовке блока
    4. Проверить заголовок блока (PoW, цепочка)
    """
    # Вычисляем root из proof
    computed_root = tx_hash
    for sibling, position in merkle_proof:
        if position == 'left':
            computed_root = hash256(sibling + computed_root)
        else:
            computed_root = hash256(computed_root + sibling)

    return computed_root == merkle_root
```

### 2. Merkle Airdrop

```python
def create_airdrop_merkle(recipients: List[dict]) -> MerkleTree:
    """
    Создание Merkle tree для airdrop:
    - Каждый лист = hash(address, amount)
    - Контракт хранит только root
    - Пользователи предоставляют proof для claim
    """
    leaves = []
    for r in recipients:
        leaf_data = r['address'].encode() + r['amount'].to_bytes(32, 'big')
        leaves.append(leaf_data)

    return MerkleTree(leaves)

# Пример
recipients = [
    {"address": "0x1234...", "amount": 1000},
    {"address": "0x5678...", "amount": 2000},
    {"address": "0x9abc...", "amount": 500},
]

airdrop_tree = create_airdrop_merkle(recipients)
print(f"Airdrop merkle root: {airdrop_tree.root.hex()}")
```

### 3. Whitelist для NFT mint

```solidity
// Solidity контракт для merkle whitelist
contract MerkleWhitelist {
    bytes32 public merkleRoot;

    function mint(bytes32[] calldata proof) external {
        bytes32 leaf = keccak256(abi.encodePacked(msg.sender));
        require(verify(proof, merkleRoot, leaf), "Invalid proof");
        // Mint NFT
    }

    function verify(
        bytes32[] memory proof,
        bytes32 root,
        bytes32 leaf
    ) internal pure returns (bool) {
        bytes32 computedHash = leaf;
        for (uint256 i = 0; i < proof.length; i++) {
            bytes32 proofElement = proof[i];
            if (computedHash <= proofElement) {
                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));
            } else {
                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));
            }
        }
        return computedHash == root;
    }
}
```

## Ключевые выводы

1. **Дерево Меркла** — бинарное дерево хешей с корнем, представляющим все данные
2. **Merkle Root** — компактное представление любого количества данных
3. **Merkle Proof** — доказательство включения за O(log n) хешей
4. **SPV** — легкие клиенты могут верифицировать транзакции без полного блокчейна
5. **Airdrop/Whitelist** — эффективное хранение больших списков on-chain

## Что дальше?

В следующем уроке мы изучим **Merkle Proofs** подробнее — как генерировать, верифицировать и использовать их в смарт-контрактах.
