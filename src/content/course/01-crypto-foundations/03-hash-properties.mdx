---
title: "Свойства хеш-функций"
description: "Криптографические хеш-функции — односторонние функции для защиты данных"
order: 3
difficulty: "beginner"
estimatedTime: 20
topics: ["Hash Functions", "Cryptographic Properties", "Collision Resistance"]
---

import { HashFunctionDiagram, AvalancheEffectDiagram, CollisionDiagram } from '../../../components/diagrams/module1';

# Криптографические хеш-функции

## Что такое хеш-функция?

**Хеш-функция** — это функция, которая преобразует данные произвольной длины в строку фиксированной длины (хеш, дайджест, отпечаток).

<HashFunctionDiagram client:load />

```python
import hashlib

# Любой вход → фиксированный выход (256 бит для SHA-256)
print(hashlib.sha256(b"Hello").hexdigest())
# a591a6d40bf420404a011733cfb7b190d62c65bf0bcda32b57b277d9ad9f146e

print(hashlib.sha256(b"Hello World" * 1000).hexdigest())
# Тот же размер: 64 hex символа = 256 бит
```

## Три ключевых свойства

Криптографическая хеш-функция должна обладать тремя свойствами:

### 1. Стойкость к прообразу (Preimage Resistance)

Имея хеш h, вычислительно невозможно найти сообщение m, такое что H(m) = h.

```python
# Легко: вычислить хеш
message = b"secret password"
hash_value = hashlib.sha256(message).hexdigest()
print(f"Hash: {hash_value}")

# Сложно (невозможно): найти message, зная только hash_value
# Единственный способ — перебор (brute force)
```

**Применение:** Хранение паролей. Даже если база утекла, восстановить пароли невозможно.

### 2. Стойкость ко второму прообразу (Second Preimage Resistance)

Имея сообщение m₁, невозможно найти m₂ ≠ m₁, такое что H(m₁) = H(m₂).

```python
original = b"Transfer $100 to Alice"
original_hash = hashlib.sha256(original).hexdigest()

# Невозможно найти другое сообщение с тем же хешем
# fake = b"Transfer $10000 to Eve"
# hashlib.sha256(fake).hexdigest() != original_hash (почти наверняка)
```

**Применение:** Целостность данных. Изменить документ, сохранив его хеш, невозможно.

### 3. Стойкость к коллизиям (Collision Resistance)

Невозможно найти любые два разных сообщения m₁ и m₂, такие что H(m₁) = H(m₂).

<CollisionDiagram client:load />

```python
# Парадокс дней рождения:
# Для 256-битного хеша нужно ~2^128 попыток для нахождения коллизии
# Это вычислительно невозможно с современными компьютерами

# Для сравнения: 2^128 ≈ 3.4 × 10^38
# Даже при 1 триллион хешей в секунду понадобится 10^19 лет
```

**Применение:** Цифровые подписи. Подписываем хеш документа, а не сам документ.

## Эффект лавины (Avalanche Effect)

Изменение одного бита во входных данных должно изменить примерно 50% битов на выходе.

<AvalancheEffectDiagram client:load />

```python
def hex_to_bits(hex_str):
    """Преобразует hex строку в строку битов"""
    return bin(int(hex_str, 16))[2:].zfill(256)

def hamming_distance(bits1, bits2):
    """Количество различающихся битов"""
    return sum(b1 != b2 for b1, b2 in zip(bits1, bits2))

# Два сообщения, отличающиеся одним символом
msg1 = b"Hello World"
msg2 = b"Hello world"  # Изменили W -> w

hash1 = hashlib.sha256(msg1).hexdigest()
hash2 = hashlib.sha256(msg2).hexdigest()

bits1 = hex_to_bits(hash1)
bits2 = hex_to_bits(hash2)

diff = hamming_distance(bits1, bits2)
print(f"Hash 1: {hash1}")
print(f"Hash 2: {hash2}")
print(f"Различающихся битов: {diff}/256 ({diff/256*100:.1f}%)")
# Примерно 128 битов (~50%) будут различаться
```

## Детерминированность

Один и тот же вход всегда дает один и тот же выход:

```python
for i in range(5):
    h = hashlib.sha256(b"constant input").hexdigest()
    print(h)
# Все 5 хешей идентичны
```

## Почему хеш-функции работают?

Внутри хеш-функции происходят сложные нелинейные преобразования:
- **Побитовые операции**: XOR, AND, OR, NOT
- **Циклические сдвиги**: вращение битов
- **Модулярная арифметика**: сложение по модулю 2³²
- **Смешивание**: каждый входной бит влияет на все выходные

```python
# Упрощенная демонстрация смешивания
def simple_mix(a, b, c):
    """Пример функции смешивания"""
    a = (a + b) & 0xFFFFFFFF
    c = c ^ a
    c = ((c << 7) | (c >> 25)) & 0xFFFFFFFF  # Rotate left by 7
    b = (b + c) & 0xFFFFFFFF
    a = a ^ b
    a = ((a << 12) | (a >> 20)) & 0xFFFFFFFF  # Rotate left by 12
    return a, b, c

# Многократное применение таких операций создает "лавинный эффект"
```

## Популярные хеш-функции

| Функция | Размер выхода | Использование |
|---------|---------------|---------------|
| MD5 | 128 бит | **Небезопасна!** Только для контрольных сумм |
| SHA-1 | 160 бит | **Небезопасна!** Найдены практические коллизии |
| SHA-256 | 256 бит | Bitcoin, SSL/TLS, повсеместно |
| SHA-3 | 224-512 бит | Стандарт NIST, отличается от SHA-2 |
| Keccak | 256 бит | Ethereum (не совсем SHA-3!) |
| BLAKE2 | 256-512 бит | Быстрая, используется в криптовалютах |

```python
import hashlib

message = b"Test message"

# Разные алгоритмы
print(f"MD5:     {hashlib.md5(message).hexdigest()}")
print(f"SHA-1:   {hashlib.sha1(message).hexdigest()}")
print(f"SHA-256: {hashlib.sha256(message).hexdigest()}")
print(f"SHA-3:   {hashlib.sha3_256(message).hexdigest()}")
print(f"BLAKE2:  {hashlib.blake2s(message).hexdigest()}")
```

## Применение в блокчейне

### 1. Идентификация блоков
```python
# Хеш блока = идентификатор
block_hash = hashlib.sha256(b"block data...").hexdigest()
# 000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f
```

### 2. Merkle Trees
```python
# Хеши транзакций объединяются в дерево
tx1_hash = hashlib.sha256(b"tx1").digest()
tx2_hash = hashlib.sha256(b"tx2").digest()
merkle_root = hashlib.sha256(tx1_hash + tx2_hash).hexdigest()
```

### 3. Proof of Work
```python
# Майнинг = поиск nonce, дающего хеш с заданным количеством нулей
def mine_block(data, difficulty):
    nonce = 0
    target = "0" * difficulty
    while True:
        attempt = f"{data}{nonce}".encode()
        hash_result = hashlib.sha256(attempt).hexdigest()
        if hash_result.startswith(target):
            return nonce, hash_result
        nonce += 1

# Найти хеш, начинающийся с 4 нулей
nonce, hash_value = mine_block("Hello", 4)
print(f"Nonce: {nonce}, Hash: {hash_value}")
```

### 4. Адреса кошельков
```python
# Bitcoin адрес = RIPEMD160(SHA256(public_key))
# Ethereum адрес = последние 20 байт Keccak256(public_key)
```

## Ключевые выводы

1. **Хеш-функция** — детерминированное преобразование в фиксированную длину
2. **Три свойства**: стойкость к прообразу, второму прообразу, коллизиям
3. **Эффект лавины** — малое изменение входа меняет ~50% выхода
4. **SHA-256** — основа Bitcoin, надежна и широко используется
5. **Keccak** — основа Ethereum, отличается от SHA-3

## Что дальше?

В следующем уроке мы разберем **SHA-256 изнутри** — пошагово пройдем весь алгоритм и реализуем его с нуля на Python.
