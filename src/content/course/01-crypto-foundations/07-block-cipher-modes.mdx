---
title: "Режимы работы блочных шифров"
description: "ECB, CBC, CTR, GCM — как правильно использовать блочные шифры"
order: 7
difficulty: "intermediate"
estimatedTime: 25
topics: ["Block Cipher Modes", "CBC", "CTR", "GCM", "Authenticated Encryption"]
---

import { ECBModeDiagram, CBCModeDiagram, CTRModeDiagram, GCMModeDiagram } from '../../../components/diagrams/module1';

# Режимы работы блочных шифров

## Проблема блочного шифра

AES шифрует только **один блок** (16 байт). Как зашифровать сообщение большего размера? Для этого существуют **режимы работы** (modes of operation).

## ECB — Electronic Codebook (НЕ ИСПОЛЬЗОВАТЬ!)

Каждый блок шифруется независимо.

<ECBModeDiagram client:load />

```python
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad

key = b"0123456789abcdef"

# ECB: одинаковые блоки → одинаковый шифротекст!
cipher = AES.new(key, AES.MODE_ECB)

block1 = b"AAAAAAAAAAAAAAAA"  # 16 A
block2 = b"AAAAAAAAAAAAAAAA"  # 16 A
block3 = b"BBBBBBBBBBBBBBBB"  # 16 B

c1 = cipher.encrypt(block1)
c2 = cipher.encrypt(block2)
c3 = cipher.encrypt(block3)

print(f"Block1 cipher: {c1.hex()}")
print(f"Block2 cipher: {c2.hex()}")
print(f"Block3 cipher: {c3.hex()}")
print(f"c1 == c2: {c1 == c2}")  # True! Утечка информации!
```

**Почему ECB опасен:**
- Одинаковые блоки → одинаковый шифротекст
- Паттерны в данных сохраняются
- Классический пример: "ECB пингвин"

```python
# Демонстрация проблемы ECB на изображении
# Структура изображения сохраняется после шифрования!
```

## CBC — Cipher Block Chaining

Каждый блок XOR-ится с предыдущим шифротекстом перед шифрованием.

<CBCModeDiagram client:load />

```python
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
from Crypto.Util.Padding import pad, unpad

def cbc_encrypt(key: bytes, plaintext: bytes) -> tuple:
    """CBC шифрование"""
    iv = get_random_bytes(16)
    cipher = AES.new(key, AES.MODE_CBC, iv)
    padded = pad(plaintext, 16)
    ciphertext = cipher.encrypt(padded)
    return iv, ciphertext

def cbc_decrypt(key: bytes, iv: bytes, ciphertext: bytes) -> bytes:
    """CBC расшифрование"""
    cipher = AES.new(key, AES.MODE_CBC, iv)
    padded = cipher.decrypt(ciphertext)
    return unpad(padded, 16)

# Использование
key = b"0123456789abcdef"
message = b"Hello, CBC mode!"

iv, ciphertext = cbc_encrypt(key, message)
decrypted = cbc_decrypt(key, iv, ciphertext)

print(f"Original:  {message}")
print(f"IV:        {iv.hex()}")
print(f"Cipher:    {ciphertext.hex()}")
print(f"Decrypted: {decrypted}")
```

### Проблемы CBC

1. **Padding Oracle Attack** — если сервер сообщает об ошибке паддинга, можно расшифровать данные
2. **Нельзя параллелить шифрование** — каждый блок зависит от предыдущего
3. **IV должен быть случайным** — предсказуемый IV → уязвимость

## CTR — Counter Mode

Блочный шифр превращается в **потоковый**. Шифруется счетчик, результат XOR-ится с данными.

<CTRModeDiagram client:load />

```python
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes

def ctr_encrypt(key: bytes, plaintext: bytes) -> tuple:
    """CTR шифрование"""
    nonce = get_random_bytes(8)  # 8 байт nonce + 8 байт counter
    cipher = AES.new(key, AES.MODE_CTR, nonce=nonce)
    ciphertext = cipher.encrypt(plaintext)
    return nonce, ciphertext

def ctr_decrypt(key: bytes, nonce: bytes, ciphertext: bytes) -> bytes:
    """CTR расшифрование"""
    cipher = AES.new(key, AES.MODE_CTR, nonce=nonce)
    return cipher.decrypt(ciphertext)

# CTR: паддинг не нужен!
key = b"0123456789abcdef"
message = b"CTR mode works with any length!"

nonce, ciphertext = ctr_encrypt(key, message)
decrypted = ctr_decrypt(key, nonce, ciphertext)

print(f"Original:  {message}")
print(f"Nonce:     {nonce.hex()}")
print(f"Cipher:    {ciphertext.hex()}")
print(f"Decrypted: {decrypted}")
```

### Преимущества CTR

1. **Параллельное шифрование/расшифрование**
2. **Нет паддинга** — шифруем данные любой длины
3. **Произвольный доступ** — можем расшифровать любой блок

### Критическая уязвимость CTR

**НИКОГДА не используйте один nonce дважды!**

```python
# Демонстрация катастрофы при повторном nonce
key = b"0123456789abcdef"
nonce = b"BADNONCE"  # Повторно используемый nonce

cipher1 = AES.new(key, AES.MODE_CTR, nonce=nonce)
cipher2 = AES.new(key, AES.MODE_CTR, nonce=nonce)

m1 = b"Secret message 1"
m2 = b"Secret message 2"

c1 = cipher1.encrypt(m1)
c2 = cipher2.encrypt(m2)

# Атакующий знает c1, c2 и может вычислить m1 XOR m2:
xor_plaintexts = bytes(a ^ b for a, b in zip(c1, c2))
print(f"m1 XOR m2: {xor_plaintexts}")
# Это утечка информации! С достаточным количеством пар можно восстановить тексты.
```

## GCM — Galois/Counter Mode

**Аутентифицированное шифрование**: конфиденциальность + целостность + аутентификация.

<GCMModeDiagram client:load />

```python
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes

def gcm_encrypt(key: bytes, plaintext: bytes, aad: bytes = b"") -> tuple:
    """
    GCM шифрование с аутентификацией
    - aad (Additional Authenticated Data) — не шифруется, но аутентифицируется
    """
    nonce = get_random_bytes(12)  # 96-bit nonce рекомендуется
    cipher = AES.new(key, AES.MODE_GCM, nonce=nonce)

    if aad:
        cipher.update(aad)

    ciphertext, tag = cipher.encrypt_and_digest(plaintext)
    return nonce, ciphertext, tag

def gcm_decrypt(key: bytes, nonce: bytes, ciphertext: bytes,
                 tag: bytes, aad: bytes = b"") -> bytes:
    """GCM расшифрование с проверкой аутентификации"""
    cipher = AES.new(key, AES.MODE_GCM, nonce=nonce)

    if aad:
        cipher.update(aad)

    try:
        plaintext = cipher.decrypt_and_verify(ciphertext, tag)
        return plaintext
    except ValueError:
        raise Exception("Authentication failed! Data was tampered with.")

# Использование
key = b"0123456789abcdef"
message = b"Sensitive transaction data"
header = b"Transaction ID: 12345"  # AAD: открытые метаданные

nonce, ciphertext, tag = gcm_encrypt(key, message, aad=header)
print(f"Nonce:  {nonce.hex()}")
print(f"Cipher: {ciphertext.hex()}")
print(f"Tag:    {tag.hex()}")

# Успешное расшифрование
decrypted = gcm_decrypt(key, nonce, ciphertext, tag, aad=header)
print(f"Decrypted: {decrypted}")

# Попытка подделки
try:
    tampered = bytes([ciphertext[0] ^ 1]) + ciphertext[1:]
    gcm_decrypt(key, nonce, tampered, tag, aad=header)
except Exception as e:
    print(f"Tamper detected: {e}")
```

### Почему GCM — лучший выбор

| Свойство | ECB | CBC | CTR | GCM |
|----------|-----|-----|-----|-----|
| Конфиденциальность | ❌ Паттерны | ✓ | ✓ | ✓ |
| Целостность | ❌ | ❌ | ❌ | ✓ |
| Параллельность | ✓ | ❌ | ✓ | ✓ |
| Без паддинга | ❌ | ❌ | ✓ | ✓ |

## ChaCha20-Poly1305

Альтернатива AES-GCM, популярная в мобильных устройствах (быстрее без AES-NI).

```python
from Crypto.Cipher import ChaCha20_Poly1305
from Crypto.Random import get_random_bytes

def chacha_encrypt(key: bytes, plaintext: bytes, aad: bytes = b"") -> tuple:
    """ChaCha20-Poly1305 шифрование"""
    nonce = get_random_bytes(12)
    cipher = ChaCha20_Poly1305.new(key=key, nonce=nonce)

    if aad:
        cipher.update(aad)

    ciphertext, tag = cipher.encrypt_and_digest(plaintext)
    return nonce, ciphertext, tag

# ChaCha20 использует 256-битный ключ
key = get_random_bytes(32)
message = b"ChaCha20 is faster on devices without AES hardware!"

nonce, ciphertext, tag = chacha_encrypt(key, message)
print(f"ChaCha20 ciphertext: {ciphertext.hex()[:64]}...")
```

## Применение в блокчейне

### 1. Ethereum Keystore (AES-128-CTR)

```python
import json
from Crypto.Cipher import AES
from Crypto.Protocol.KDF import scrypt
from Crypto.Random import get_random_bytes
from Crypto.Hash import keccak

def create_keystore(private_key: bytes, password: str) -> dict:
    """Создать Ethereum keystore файл"""
    salt = get_random_bytes(32)
    iv = get_random_bytes(16)

    # Derive key from password
    derived = scrypt(password.encode(), salt, key_len=32, N=2**18, r=8, p=1)
    enc_key = derived[:16]
    mac_key = derived[16:]

    # Encrypt with AES-128-CTR
    cipher = AES.new(enc_key, AES.MODE_CTR, nonce=iv[:8])
    ciphertext = cipher.encrypt(private_key)

    # MAC for integrity
    mac = keccak.new(digest_bits=256)
    mac.update(mac_key + ciphertext)

    return {
        "version": 3,
        "crypto": {
            "cipher": "aes-128-ctr",
            "ciphertext": ciphertext.hex(),
            "cipherparams": {"iv": iv.hex()},
            "kdf": "scrypt",
            "kdfparams": {
                "n": 2**18,
                "r": 8,
                "p": 1,
                "dklen": 32,
                "salt": salt.hex()
            },
            "mac": mac.hexdigest()
        }
    }
```

### 2. Шифрование метаданных транзакций

```python
def encrypt_memo(key: bytes, memo: str) -> dict:
    """Зашифровать memo транзакции"""
    nonce, ciphertext, tag = gcm_encrypt(
        key,
        memo.encode('utf-8')
    )
    return {
        "nonce": nonce.hex(),
        "ciphertext": ciphertext.hex(),
        "tag": tag.hex()
    }
```

## Ключевые выводы

1. **ECB** — никогда не использовать для шифрования данных
2. **CBC** — требует паддинг, уязвим к padding oracle
3. **CTR** — потоковый режим, критично не повторять nonce
4. **GCM** — лучший выбор: шифрование + аутентификация
5. **ChaCha20-Poly1305** — альтернатива GCM для устройств без AES-NI

## Что дальше?

В следующем уроке мы изучим **RSA** — первый практический алгоритм асимметричной криптографии, и поймем математику за ним.
