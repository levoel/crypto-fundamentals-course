---
title: "Модулярная арифметика"
description: "Основы модулярной арифметики — фундамент всей криптографии"
order: 1
difficulty: "beginner"
estimatedTime: 20
topics: ["Modular Arithmetic", "Finite Fields", "Mathematics"]
---

import { ModularClockDiagram, ModularOperationsDiagram } from '../../../components/diagrams/module1';

# Модулярная арифметика

## Зачем криптографии математика?

Прежде чем погружаться в хеш-функции и цифровые подписи, нужно понять **модулярную арифметику** — математический фундамент, на котором строится вся современная криптография.

> **Ключевой инсайт:** Модулярная арифметика позволяет работать с огромными числами, сохраняя результат в управляемом диапазоне. Это основа всех криптографических операций.

## Что такое модуль?

Представьте часы. Когда стрелка доходит до 12, она не показывает 13 — она возвращается к 1. Это и есть модулярная арифметика!

<ModularClockDiagram client:load />

Математически это записывается так:

```
13 mod 12 = 1
25 mod 12 = 1
14 mod 12 = 2
```

Операция `mod` (модуль) возвращает остаток от деления.

## Формальное определение

Говорят, что **a ≡ b (mod n)** (читается "a конгруэнтно b по модулю n"), если разность (a - b) делится на n без остатка.

```python
# Примеры в Python
print(17 % 5)   # 2, потому что 17 = 5*3 + 2
print(23 % 7)   # 2, потому что 23 = 7*3 + 2
print(-3 % 5)   # 2, потому что -3 = 5*(-1) + 2
```

## Свойства модулярной арифметики

### Сложение и вычитание

```python
# (a + b) mod n = ((a mod n) + (b mod n)) mod n
(15 + 27) % 7   # = 42 % 7 = 0
(15 % 7 + 27 % 7) % 7  # = (1 + 6) % 7 = 0  ✓
```

### Умножение

```python
# (a * b) mod n = ((a mod n) * (b mod n)) mod n
(8 * 9) % 7    # = 72 % 7 = 2
(8 % 7 * 9 % 7) % 7  # = (1 * 2) % 7 = 2  ✓
```

<ModularOperationsDiagram client:load />

## Почему это важно для криптографии?

### 1. Работа с большими числами

В криптографии мы работаем с числами длиной 256+ бит. Без модулярной арифметики результаты операций быстро становятся неуправляемыми:

```python
# Без модуля: числа растут экспоненциально
2 ** 256  # Число с 78 цифрами!

# С модулем: результат всегда в заданном диапазоне
p = 2**256 - 2**32 - 977  # secp256k1 prime
(2 ** 256) % p  # Всегда < p
```

### 2. Необратимость операций

Модулярная арифметика создает "односторонние" функции — легко вычислить в одном направлении, сложно в обратном:

```python
# Легко: вычислить a^e mod n
pow(3, 17, 23)  # = 15

# Сложно: найти e, зная 3^e ≡ 15 (mod 23)
# Это дискретный логарифм — вычислительно сложная задача
```

### 3. Циклические группы

Модулярная арифметика создает циклические структуры, которые используются в:
- **RSA** — для генерации ключей
- **Elliptic Curves** — для операций на кривых
- **Diffie-Hellman** — для обмена ключами

## Практика: реализация на Python

```python
def mod_add(a: int, b: int, n: int) -> int:
    """Модулярное сложение"""
    return (a + b) % n

def mod_mul(a: int, b: int, n: int) -> int:
    """Модулярное умножение"""
    return (a * b) % n

def mod_pow(base: int, exp: int, n: int) -> int:
    """Модулярное возведение в степень (быстрое)"""
    result = 1
    base = base % n
    while exp > 0:
        if exp % 2 == 1:
            result = (result * base) % n
        exp = exp >> 1
        base = (base * base) % n
    return result

# Тест
p = 23
g = 5
x = 7  # приватный ключ

# Вычисляем публичный ключ: g^x mod p
public_key = mod_pow(g, x, p)
print(f"Public key: {public_key}")  # 17
```

## Обратный элемент

В модулярной арифметике есть понятие **обратного элемента**. Для числа a обратный элемент a⁻¹ — это такое число, что:

```
a * a⁻¹ ≡ 1 (mod n)
```

Обратный элемент существует только если gcd(a, n) = 1 (числа взаимно просты).

```python
def mod_inverse(a: int, n: int) -> int:
    """Обратный элемент через расширенный алгоритм Евклида"""
    def extended_gcd(a, b):
        if a == 0:
            return b, 0, 1
        gcd, x1, y1 = extended_gcd(b % a, a)
        x = y1 - (b // a) * x1
        y = x1
        return gcd, x, y

    gcd, x, _ = extended_gcd(a % n, n)
    if gcd != 1:
        raise ValueError("Обратный элемент не существует")
    return (x % n + n) % n

# Проверка
a = 3
n = 7
a_inv = mod_inverse(a, n)
print(f"{a} * {a_inv} mod {n} = {(a * a_inv) % n}")  # 1
```

## Ключевые выводы

1. **Модулярная арифметика** — операции над остатками от деления
2. **Свойства сохраняются** — сложение и умножение работают "как обычно"
3. **Ограниченный диапазон** — результат всегда меньше модуля
4. **Необратимость** — некоторые операции легко вычислить, но сложно обратить
5. **Обратный элемент** — существует для взаимно простых чисел

## Что дальше?

В следующем уроке мы изучим **группы и конечные поля** — абстрактные структуры, которые формализуют модулярную арифметику и используются в эллиптических кривых.
