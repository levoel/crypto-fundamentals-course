---
title: "Merkle Proofs"
description: "Криптографические доказательства включения в дерево Меркла"
order: 14
difficulty: "intermediate"
estimatedTime: 25
topics: ["Merkle Proofs", "SPV", "Light Clients", "Smart Contracts"]
---

import { MerkleProofDiagram, SPVVerificationDiagram, MultiProofDiagram } from '../../../components/diagrams/module1';

# Merkle Proofs

## Что такое Merkle Proof?

**Merkle Proof** — это минимальный набор хешей, необходимый для доказательства включения элемента в дерево Меркла.

<MerkleProofDiagram client:load />

### Размер proof

Для дерева с n листьями:
- **Размер proof**: O(log₂ n) хешей
- **1 миллион элементов**: ~20 хешей × 32 байта = 640 байт

```python
import math

def proof_size(n_leaves: int, hash_size: int = 32) -> int:
    """Вычислить размер proof в байтах"""
    levels = math.ceil(math.log2(n_leaves)) if n_leaves > 0 else 0
    return levels * hash_size

# Примеры
for n in [100, 1000, 10000, 1000000]:
    size = proof_size(n)
    print(f"Leaves: {n:>8} | Proof size: {size:>4} bytes ({size // 32} hashes)")
```

## Генерация Merkle Proof

```python
import hashlib
from typing import List, Tuple

def keccak256(data: bytes) -> bytes:
    """Keccak256 хеш (как в Ethereum)"""
    from Crypto.Hash import keccak
    k = keccak.new(digest_bits=256)
    k.update(data)
    return k.digest()

class MerkleTree:
    """Дерево Меркла с поддержкой proof"""

    def __init__(self, leaves: List[bytes], hash_func=keccak256):
        self.hash_func = hash_func
        # Сортируем листья для детерминированности (как в OpenZeppelin)
        self.original_leaves = leaves
        self.sorted_leaves = sorted(leaves)
        self.tree = self._build()
        self.leaf_to_index = {leaf: i for i, leaf in enumerate(self.sorted_leaves)}

    def _build(self) -> List[List[bytes]]:
        """Построить дерево"""
        if not self.sorted_leaves:
            return [[self.hash_func(b'')]]

        tree = [self.sorted_leaves[:]]
        current = self.sorted_leaves[:]

        while len(current) > 1:
            next_level = []
            for i in range(0, len(current), 2):
                if i + 1 < len(current):
                    # Сортируем пару для детерминированности
                    pair = sorted([current[i], current[i + 1]])
                    combined = pair[0] + pair[1]
                else:
                    combined = current[i] + current[i]
                next_level.append(self.hash_func(combined))
            tree.append(next_level)
            current = next_level

        return tree

    @property
    def root(self) -> bytes:
        return self.tree[-1][0]

    def get_proof(self, leaf: bytes) -> List[bytes]:
        """Получить proof для листа"""
        if leaf not in self.leaf_to_index:
            raise ValueError("Leaf not in tree")

        proof = []
        index = self.leaf_to_index[leaf]

        for level in self.tree[:-1]:
            if index % 2 == 0:
                sibling_index = index + 1
            else:
                sibling_index = index - 1

            if sibling_index < len(level):
                proof.append(level[sibling_index])

            index //= 2

        return proof

    @classmethod
    def verify(cls, leaf: bytes, proof: List[bytes], root: bytes,
               hash_func=keccak256) -> bool:
        """Статический метод верификации proof"""
        current = leaf

        for sibling in proof:
            # Сортируем для детерминированности
            pair = sorted([current, sibling])
            current = hash_func(pair[0] + pair[1])

        return current == root

# Пример использования
addresses = [
    bytes.fromhex("0000000000000000000000001111111111111111111111111111111111111111"),
    bytes.fromhex("0000000000000000000000002222222222222222222222222222222222222222"),
    bytes.fromhex("0000000000000000000000003333333333333333333333333333333333333333"),
    bytes.fromhex("0000000000000000000000004444444444444444444444444444444444444444"),
]

# Листья = хеши адресов
leaves = [keccak256(addr) for addr in addresses]

tree = MerkleTree(leaves)
print(f"Root: {tree.root.hex()}")

# Proof для первого адреса
target_leaf = keccak256(addresses[0])
proof = tree.get_proof(target_leaf)
print(f"\nProof for address[0]:")
for i, h in enumerate(proof):
    print(f"  [{i}] {h.hex()}")

# Верификация
is_valid = MerkleTree.verify(target_leaf, proof, tree.root)
print(f"\nValid: {is_valid}")
```

## SPV (Simplified Payment Verification)

<SPVVerificationDiagram client:load />

SPV позволяет легким клиентам верифицировать транзакции:

```python
class SPVClient:
    """Упрощенный SPV клиент"""

    def __init__(self, block_headers: List[dict]):
        """
        Легкий клиент хранит только заголовки блоков
        Каждый заголовок ~80 байт vs ~1MB полный блок
        """
        self.headers = {h['hash']: h for h in block_headers}

    def verify_transaction(
        self,
        tx_hash: bytes,
        merkle_proof: List[bytes],
        block_hash: bytes
    ) -> dict:
        """
        Верификация транзакции:
        1. Получить заголовок блока
        2. Вычислить merkle root из proof
        3. Сравнить с merkle_root в заголовке
        4. Вернуть информацию о подтверждении
        """
        header = self.headers.get(block_hash)
        if not header:
            return {"verified": False, "error": "Block not found"}

        # Вычисляем root из proof
        computed_root = tx_hash
        for sibling in merkle_proof:
            pair = sorted([computed_root, sibling])
            computed_root = hashlib.sha256(
                hashlib.sha256(pair[0] + pair[1]).digest()
            ).digest()

        if computed_root != header['merkle_root']:
            return {"verified": False, "error": "Invalid merkle proof"}

        return {
            "verified": True,
            "block_height": header['height'],
            "confirmations": self._count_confirmations(block_hash)
        }

    def _count_confirmations(self, block_hash: bytes) -> int:
        """Подсчет подтверждений"""
        # Упрощенная реализация
        return 6  # Предположим 6 подтверждений

# Демонстрация
print("SPV верификация:")
print("1. Клиент хранит только заголовки блоков (~80 байт каждый)")
print("2. Запрашивает merkle proof от полного узла")
print("3. Проверяет proof против merkle_root в заголовке")
print("4. Не нужно скачивать полные блоки!")
```

## Multi-Proofs

<MultiProofDiagram client:load />

Для множественной верификации можно использовать оптимизированные multi-proofs:

```python
def create_multi_proof(tree: MerkleTree, indices: List[int]) -> dict:
    """
    Создать proof для нескольких элементов:
    - Исключаем дублирующиеся хеши
    - Размер меньше чем сумма отдельных proofs
    """
    proof_hashes = set()
    flags = []

    indices_set = set(indices)
    current_indices = set(indices)

    for level in range(len(tree.tree) - 1):
        next_indices = set()
        for idx in sorted(current_indices):
            sibling_idx = idx ^ 1  # XOR для получения сестринского индекса

            if sibling_idx in current_indices:
                # Оба узла в proof, не добавляем сестринский
                flags.append(True)
            else:
                # Добавляем сестринский хеш
                if sibling_idx < len(tree.tree[level]):
                    proof_hashes.add(tree.tree[level][sibling_idx])
                flags.append(False)

            next_indices.add(idx // 2)

        current_indices = next_indices

    return {
        "proof": list(proof_hashes),
        "flags": flags,
        "leaves": [tree.tree[0][i] for i in indices]
    }
```

## Merkle Proof в Solidity

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";

contract MerkleVerifier {
    bytes32 public immutable merkleRoot;

    mapping(address => bool) public claimed;

    constructor(bytes32 _merkleRoot) {
        merkleRoot = _merkleRoot;
    }

    /**
     * @notice Проверка proof и выполнение действия
     * @param proof Массив хешей для верификации
     */
    function claim(bytes32[] calldata proof) external {
        require(!claimed[msg.sender], "Already claimed");

        // Создаем лист из адреса
        bytes32 leaf = keccak256(abi.encodePacked(msg.sender));

        // Верификация proof
        require(
            MerkleProof.verify(proof, merkleRoot, leaf),
            "Invalid proof"
        );

        claimed[msg.sender] = true;

        // Выполняем действие (transfer, mint, etc.)
    }

    /**
     * @notice Проверка с дополнительными данными
     */
    function claimWithAmount(
        bytes32[] calldata proof,
        uint256 amount
    ) external {
        require(!claimed[msg.sender], "Already claimed");

        // Лист включает адрес и количество
        bytes32 leaf = keccak256(abi.encodePacked(msg.sender, amount));

        require(
            MerkleProof.verify(proof, merkleRoot, leaf),
            "Invalid proof"
        );

        claimed[msg.sender] = true;

        // Transfer amount to msg.sender
    }
}
```

## Генерация proof для смарт-контракта

```python
from eth_abi import encode

def generate_solidity_proof(
    addresses: List[str],
    amounts: List[int],
    target_address: str,
    target_amount: int
) -> dict:
    """
    Генерация proof для Solidity контракта:
    - Использует keccak256
    - Кодирует данные как в Solidity
    """
    # Создаем листья (как в Solidity: keccak256(abi.encodePacked(address, amount)))
    leaves = []
    for addr, amount in zip(addresses, amounts):
        # abi.encodePacked(address, uint256)
        packed = bytes.fromhex(addr[2:]) + amount.to_bytes(32, 'big')
        leaf = keccak256(packed)
        leaves.append(leaf)

    tree = MerkleTree(leaves)

    # Находим целевой лист
    target_packed = bytes.fromhex(target_address[2:]) + target_amount.to_bytes(32, 'big')
    target_leaf = keccak256(target_packed)

    proof = tree.get_proof(target_leaf)

    return {
        "root": "0x" + tree.root.hex(),
        "proof": ["0x" + p.hex() for p in proof],
        "leaf": "0x" + target_leaf.hex()
    }

# Пример
addresses = [
    "0x1111111111111111111111111111111111111111",
    "0x2222222222222222222222222222222222222222",
    "0x3333333333333333333333333333333333333333",
    "0x4444444444444444444444444444444444444444",
]
amounts = [100, 200, 150, 300]

result = generate_solidity_proof(
    addresses, amounts,
    "0x2222222222222222222222222222222222222222", 200
)

print("Solidity-compatible proof:")
print(f"  Root: {result['root']}")
print(f"  Proof: {result['proof']}")
```

## Практические применения

### 1. Airdrop с Merkle Proof

```python
def create_airdrop(recipients: dict) -> dict:
    """
    Создать Merkle airdrop:
    - recipients: {address: amount}
    - Возвращает root и функцию для получения proof
    """
    addresses = list(recipients.keys())
    amounts = list(recipients.values())

    leaves = []
    leaf_data = {}

    for addr, amount in recipients.items():
        packed = bytes.fromhex(addr[2:]) + amount.to_bytes(32, 'big')
        leaf = keccak256(packed)
        leaves.append(leaf)
        leaf_data[addr] = {"leaf": leaf, "amount": amount}

    tree = MerkleTree(leaves)

    return {
        "root": tree.root,
        "get_proof": lambda addr: tree.get_proof(leaf_data[addr]["leaf"]),
        "recipients": len(recipients)
    }

# Создаем airdrop
airdrop = create_airdrop({
    "0x1111111111111111111111111111111111111111": 1000,
    "0x2222222222222222222222222222222222222222": 2000,
    "0x3333333333333333333333333333333333333333": 1500,
})

print(f"Airdrop root: {airdrop['root'].hex()}")
print(f"Recipients: {airdrop['recipients']}")
```

### 2. NFT Whitelist

```python
def create_whitelist(addresses: List[str]) -> dict:
    """Создать whitelist для NFT mint"""
    leaves = [keccak256(bytes.fromhex(addr[2:])) for addr in addresses]
    tree = MerkleTree(leaves)

    return {
        "root": tree.root,
        "get_proof": lambda addr: tree.get_proof(keccak256(bytes.fromhex(addr[2:]))),
    }
```

### 3. Data Availability

```python
# В rollups и DA layers Merkle proofs используются для:
# 1. Доказательства доступности данных
# 2. Fraud proofs
# 3. Validity proofs
```

## Ключевые выводы

1. **Merkle Proof** — O(log n) хешей для доказательства включения
2. **SPV** — легкие клиенты могут верифицировать без полных данных
3. **OpenZeppelin MerkleProof** — стандартная библиотека для Solidity
4. **Сортировка пар** обеспечивает детерминированность
5. **Применения**: airdrops, whitelists, SPV, rollups

## Завершение модуля

Поздравляем! Вы завершили модуль **Криптографические основы**. Теперь вы понимаете:

- Модулярную арифметику и конечные поля
- Хеш-функции: SHA-256 и Keccak
- Симметричное шифрование: AES
- Асимметричную криптографию: RSA и эллиптические кривые
- Цифровые подписи: ECDSA, EdDSA, Schnorr
- Деревья Меркла и криптографические доказательства

## Что дальше?

В следующем модуле мы погрузимся в **Bitcoin Deep Dive** — изучим архитектуру протокола, UTXO модель, Script, и напишем собственные транзакции.
